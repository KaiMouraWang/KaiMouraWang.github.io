<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>How to enable Chrome parallel download</title>
      <link href="/posts/cf0415bc/"/>
      <url>/posts/cf0415bc/</url>
      
        <content type="html"><![CDATA[<h1 id="How-to-enable-Chrome-Chromium-based-Browsers-Parallel-Download"><a href="#How-to-enable-Chrome-Chromium-based-Browsers-Parallel-Download" class="headerlink" title="How to enable Chrome / Chromium-based Browsers Parallel Download?"></a>How to enable Chrome / Chromium-based Browsers Parallel Download?</h1><p>Today I will introduce a useful tip for Chrome users:</p><p>Open Chrome / Brave / Chromium-based Browsers, enter: </p><pre class="line-numbers language-Chrome" data-language="Chrome"><code class="language-Chrome">chrome:&#x2F;&#x2F;flags&#x2F;#enable-parallel-downloading<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Search flags:</p><p><strong>Parallel downloading</strong></p><p>Change ‘default’ to ‘<strong>Enable</strong>‘</p><p>Restart your browser.</p><p>Now you can download with much higher speed! Enjoy!</p>]]></content>
      
      
      <categories>
          
          <category> Tips_for_daily_life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Security</title>
      <link href="/posts/c59bd5c1/"/>
      <url>/posts/c59bd5c1/</url>
      
        <content type="html"><![CDATA[<h1 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h1><p><a href="https://www.httpbin.org/">https://www.httpbin.org/</a></p>]]></content>
      
      
      <categories>
          
          <category> Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Networking</title>
      <link href="/posts/c2bcd5ce/"/>
      <url>/posts/c2bcd5ce/</url>
      
        <content type="html"><![CDATA[<h1 id="Networking"><a href="#Networking" class="headerlink" title="Networking"></a>Networking</h1><h2 id="Basic-Concept"><a href="#Basic-Concept" class="headerlink" title="Basic Concept"></a>Basic Concept</h2><h3 id="Nodes-keyword-JOIN"><a href="#Nodes-keyword-JOIN" class="headerlink" title="Nodes -  keyword: JOIN"></a><strong>Nodes -  keyword: JOIN</strong></h3><blockquote><p><strong>Node/nəʊd/ 节点</strong></p></blockquote><p>A place where things such as lines or systems join. </p><p>A network is a series of points or nodes interconnected by communication paths. Instead of creating individual polygons and trying to fit them together like a jigsaw, you start by creating nodes where lines will intersect.</p><p><strong>Examples of nodes are:</strong></p><ul><li><strong>computers</strong></li><li><strong>smartphones</strong></li><li><strong>printers</strong></li><li><strong>routers</strong></li></ul><hr><h3 id="Packet-keyword-a-small-chunk-of-data"><a href="#Packet-keyword-a-small-chunk-of-data" class="headerlink" title="Packet - keyword: a small chunk of data"></a><strong>Packet - keyword: a small chunk of data</strong></h3><p>A <strong>packet</strong> is a small chunk of data sent along a given network pathway.</p><blockquote><p><strong>packet 封包</strong></p></blockquote><blockquote><p>数据要在通讯系统中必须要先经过某些处理，才能在网络当中传递，例如将数据切割为数个区块之后，才能在网络上依照某种通讯协议来传送，这种过程就好像将包裹打包一样，称为分封。</p></blockquote><h4 id="Things-used-to-Redirect-data-packets："><a href="#Things-used-to-Redirect-data-packets：" class="headerlink" title="Things used to Redirect data packets："></a><strong>Things used to Redirect data packets：</strong></h4><ul><li>Hub - low intelligence - any packet received on one connection is  redistributed to all other connections, the ensures the packet reaches  the node it’s targeting, but also every other connected node.</li><li>Switch - medium intelligence - a switch can learn which node is on  which connection, and only redistribute the packet to the correct node.</li><li><strong>Router</strong> - high intelligence - a router can operate as a switch,  learning which node is on which connection, but it can do other jobs  too.<br>It is <strong>the only one</strong> of the three devices which is <strong>able to connect a node to the Internet</strong>.</li></ul><hr><h3 id="Web-The-World-Wide-Web"><a href="#Web-The-World-Wide-Web" class="headerlink" title="Web - The World Wide Web"></a><strong>Web</strong> - The <strong>World Wide Web</strong></h3><hr><h3 id="MAC-Physical-Address"><a href="#MAC-Physical-Address" class="headerlink" title="MAC / Physical Address"></a><strong>MAC</strong> / Physical Address</h3><p>A <strong>media access control</strong> address (MAC address) is a <strong>unique identifier</strong> assigned to <strong>a network interface controller</strong> (NIC) for use as a network address in communications within a network segment. This use is common in most <strong>IEEE 802</strong> networking technologies, including <strong>Ethernet, Wi-Fi, and Bluetooth</strong>.</p><hr><h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a><strong>IP</strong></h3><p>The <strong>Internet Protocol</strong> (IP) is the <strong>network layer</strong> communications protocol in the Internet protocol suite for relaying datagrams across network boundaries.</p><p>IP has the task of <strong>delivering packets</strong> from the source host to the destination host solely based on the <strong>IP addresses</strong> <strong>in the packet headers</strong>.</p><p>IP即Internet Protocol是互联网<strong>协议</strong>群（Internet Protocol Suite ，IPS）中众多通信协议中的一个，也是其中最重要的一个。IP 协议属于通信协议中的 <strong><u>第三层</u>网络层协议</strong> ，完成 <strong><u>路由寻址和消息传递</u></strong> 的功能。专家们一般将IPS解释为一个协议堆栈，它可以将应用程序的信息（比如电子邮件或者网页传输的内容）<u><strong>转换</strong>为网络可以传输的<strong>数据包</strong></u> .</p><hr><h3 id="Gateway-网关"><a href="#Gateway-网关" class="headerlink" title="Gateway  网关"></a><strong>Gateway</strong>  <strong>网关</strong></h3><p>A gateway is a piece of networking hardware or software used in telecommunications for telecommunications networks that allows data to flow from one discrete network to another. Gateways are distinct from routers or switches in that they communicate using <strong>more than one protocol</strong> to connect multiple networks and can operate at <strong>any of the seven layers</strong> of the open systems interconnection model (OSI). </p><p>My Keyword for <strong>GATEWAY</strong>:  <strong>TRANSLATOR</strong> <strong>翻译器</strong></p><p>A network gateway provides interoperability between networks and contains devices, such as protocol translators, impedance matchers, rate converters, fault isolators, or signal translators. </p><p>网关(Gateway)又称网间连接器、协议转换器。网关在网络层以上实现网络互连，是复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关既可以用于广域网互连，也可以用于局域网互连。 网关是一种充当<strong>转换</strong>重任的计算机系统或设备。使用在不同的通信协议、数据格式或语言，甚至体系结构完全不同的两种系统之间，<strong>网关是一个翻译器</strong>。与网桥只是简单地传达信息不同，网关对收到的信息要<strong>重新打包</strong>，以适应目的系统的需求。同层–应用层。</p><hr><h3 id="Default-Port-Numbers"><a href="#Default-Port-Numbers" class="headerlink" title="Default Port Numbers:"></a><strong>Default Port Numbers:</strong></h3><p><a href="https://docs.oracle.com/en/storage/tape-storage/sl4000/slklg/default-port-numbers.html#GUID-8B442CCE-F94D-4DFB-9F44-996DE72B2558">https://docs.oracle.com/en/storage/tape-storage/sl4000/slklg/default-port-numbers.html#GUID-8B442CCE-F94D-4DFB-9F44-996DE72B2558</a></p><hr><h2 id="Command-Line"><a href="#Command-Line" class="headerlink" title="Command Line"></a>Command Line</h2><h3 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a><strong>Ping</strong></h3><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD">ping [address]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Traceroute"><a href="#Traceroute" class="headerlink" title="Traceroute"></a><strong>Traceroute</strong></h3><pre class="line-numbers language-none"><code class="language-none">tracert [address]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">traceroute [address]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a><strong>Troubleshooting</strong></h4><p>‘traceroute’ is not recognized as an internal or external command:</p><p>If you are on <strong>Windows 11</strong>,  you should use <strong>tracert</strong> instead.</p><hr><h2 id="Networking-Models"><a href="#Networking-Models" class="headerlink" title="Networking Models"></a>Networking Models</h2><p>Two main modules you need to know about: </p><p>the <strong>OSI</strong> model, </p><p>the <strong>TCP/IP</strong> model.</p><h3 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a><strong>OSI</strong></h3><p>The <strong>Open System Interconnection</strong> (<strong>OSI</strong>) model is a 7 layer model, which is was developed by the <strong>International Organization for Standardization (ISO)</strong>.<br>It was designed to show how the software and hardware elements of a network work.</p><p>This diagram tells it all: </p><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/osi.gif" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><blockquote><p>根据建议X.200，OSI将计算机网络体系结构划分为以下七层，标有1～7，<strong>第1层在底部</strong>。 现“OSI/RM”是英文“Open Systems Interconnection Reference Model”的缩写。</p><p><strong>第7层 应用层</strong><br><strong>主条目：应用层</strong><br><strong>应用层（Application Layer）提供为应用软件而设的接口，以设置与另一应用软件之间的通信。例如: HTTP，HTTPS，FTP，TELNET，SSH，SMTP，POP3等。</strong></p><p><strong>第6层 表达层</strong><br><strong>主条目：表达层</strong><br><strong>表达层（Presentation Layer）把数据转换为能与接收者的系统格式兼容并适合传输的格式。</strong></p><p><strong>第5层 会话层</strong><br><strong>主条目：会话层</strong><br><strong>会话层（Session Layer）负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接。</strong></p><p><strong>第4层 传输层</strong><br><strong>主条目：传输层</strong><br><strong>传输层（Transport Layer）把传输表头（TH）加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。例如:传输控制协议（TCP）等。</strong></p><p><strong>第3层 网络层</strong><br><strong>主条目：网络层</strong><br><strong>网络层（Network Layer）决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成分组。网络表头包含了网络数据。例如:互联网协议（IP）等。</strong></p><p><strong>第2层 数据链路层</strong><br><strong>主条目：数据链路层</strong><br><strong>数据链路层（Data Link Layer）负责网络寻址、错误侦测和改错。当表头和表尾被加至数据包时，会形成帧。数据链表头（DLH）是包含了物理地址和错误侦测及改错的方法。数据链表尾（DLT）是一串指示数据包末端的字符串。例如以太网、无线局域网（Wi-Fi）和通用分组无线服务（GPRS）等。</strong><br><strong>分为两个子层：逻辑链路控制（logic link control，LLC）子层和介质访问控制（media access control，MAC）子层。</strong></p><p><strong>第1层 物理层</strong><br><strong>主条目：物理层</strong><br><strong>物理层（Physical Layer）在局部局域网上传送数据帧（data frame），它负责管理计算机通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机适配器等。</strong></p></blockquote><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/osi-c.png" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><blockquote><p>&lt;1&gt;    应用层<br>        OSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3、SMTP等。<br>        实际公司A的老板就是我们所述的用户，而他要发送的商业报价单，就是应用层提供的一种网络服务，当然，老板也可以选择其他服务，比如说，发一份商业合同，发一份询价单，等等。</p><p>&lt;2&gt;    表示层<br>        表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。<br>        由于公司A和公司B是不同国家的公司，他们之间的商定统一用英语作为交流的语言，所以此时表示层（公司的文秘），就是将应用层的传递信息转翻译成英语。同时为了防止别的公司看到，公司A的人也会对这份报价单做一些加密的处理。这就是表示的作用，将应用层的数据转换翻译等。</p><p>&lt;3&gt;    会话层<br>        会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。<br>        会话层的同事拿到表示层的同事转换后资料，（会话层的同事类似公司的外联部），会话层的同事那里可能会掌握本公司与其他好多公司的联系方式，这里公司就是实际传递过程中的实体。他们要管理本公司与外界好多公司的联系会话。当接收到表示层的数据后，会话层将会建立并记录本次会话，他首先要找到公司B的地址信息，然后将整份资料放进信封，并写上地址和联系方式。准备将资料寄出。等到确定公司B接收到此份报价单后，此次会话就算结束了，外联部的同事就会终止此次会话。</p><p>&lt;4&gt;   传输层<br>        传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。<br>        传输层就相当于公司中的负责快递邮件收发的人，公司自己的投递员，他们负责将上一层的要寄出的资料投递到快递公司或邮局。</p><p>&lt;5&gt;   网络层<br>       本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。<br>        网络层就相当于快递公司庞大的快递网络，全国不同的集散中心，比如说，从深圳发往北京的顺丰快递（陆运为例啊，空运好像直接就飞到北京了），首先要到顺丰的深圳集散中心，从深圳集散中心再送到武汉集散中心，从武汉集散中心再寄到北京顺义集散中心。这个每个集散中心，就相当于网络中的一个IP节点。</p><p>&lt;6&gt;   数据链路层<br>        将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。</p><p>​        数据链路层又分为2个子层：逻辑链路控制子层（LLC）和媒体访问控制子层（MAC）。</p><p>​        MAC子层处理CSMA/CD算法、数据出错校验、成帧等；LLC子层定义了一些字段使上次协议能共享数据链路层。 在实际使用中，LLC子层并非必需的。</p><p>&lt;7&gt;  物理层<br>        实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。<br>         快递寄送过程中的交通工具，就相当于我们的物理层，例如汽车，火车，飞机，船。</p></blockquote><hr><h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a><strong>TCP/IP</strong></h3><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/osi_tcpip.png" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p>]]></content>
      
      
      <categories>
          
          <category> Networking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Networking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jira</title>
      <link href="/posts/1565726e/"/>
      <url>/posts/1565726e/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Agile </category>
          
          <category> Software Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Agile </tag>
            
            <tag> Scrum </tag>
            
            <tag> Software Development </tag>
            
            <tag> Project Management </tag>
            
            <tag> DevOps </tag>
            
            <tag> Kanban </tag>
            
            <tag> Github </tag>
            
            <tag> Gitlab </tag>
            
            <tag> Jira </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git_Branch</title>
      <link href="/posts/3cc0dd7/"/>
      <url>/posts/3cc0dd7/</url>
      
        <content type="html"><![CDATA[<h1 id="Git-Branch"><a href="#Git-Branch" class="headerlink" title="Git_Branch"></a>Git_Branch</h1><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/branch.jpg" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><blockquote><p>Branch 分支 - 可以理解为“树”的“分支”</p></blockquote><p>Branches are kinda like a Parallel universes of Marvel.</p><p>With <strong>Version Control Systems (VSC)</strong>, like Git, we can separate the codebase on to many different branches.</p><h2 id="Git-Branching-Workflow-Example"><a href="#Git-Branching-Workflow-Example" class="headerlink" title="Git Branching Workflow Example"></a>Git Branching Workflow Example</h2><p>The two main branches that exist are the develop and main branches.</p><h3 id="New-Application-Features"><a href="#New-Application-Features" class="headerlink" title="New Application Features"></a>New Application Features</h3><p>Conventionally, new features are to be created in <strong>feature branch</strong>es from the develop branch, and, once the feature has been developed, the code can be reviewed by a peer in a Pull Request and deployed to a test environment for Integration or User Acceptance Testing.</p><p>If all testing and reviews pass, the <strong>Pull Request</strong> can be approved and <strong>merged into</strong> the <code>develop</code> branch.</p><h3 id="Releases"><a href="#Releases" class="headerlink" title="Releases"></a>Releases</h3><p>When there is a release approaching, a <strong>release candidate branch</strong> can be made.</p><p>On this new branch, further testing of all the new features working together can take place, and more candidates can be made on this branch to amend any issues.</p><p>Once testing has passed and the release has been signed off by the individual accountable for releases, the release candidate branch can be merged into master for the release to be deployed to a production environment.</p><p><strong>Once merged into the <u>master branch</u>, the code can be tagged or <u>marked as a release</u> on the Git service that you are using.</strong></p><p><strong>Changes must also be <u>merged back</u> into the <u>develop branch</u></strong>, so that any changes that were made to the release candidate will also be included in future releases.</p><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/branches.png" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><h2 id="Creating-and-Deleting-Branches"><a href="#Creating-and-Deleting-Branches" class="headerlink" title="Creating and Deleting Branches"></a>Creating and Deleting Branches</h2><p>Creating and Deleting Branches:</p><pre class="line-numbers language-none"><code class="language-none">git branch<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>To create a new branch, the command is:</p><pre class="line-numbers language-none"><code class="language-none">git branch [NEW_BRANCH_NAME]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>If you want to <strong>work on a new branch straight away</strong>, you can create a branch and checkout to it at the same time:</p><pre class="line-numbers language-none"><code class="language-none">git checkout -b [NEW_BRANCH_NAME]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>When you have finished working on your branch, and your code has been merged to <code>main</code>, it is good practice to <strong>delete the branch</strong>:</p><pre class="line-numbers language-none"><code class="language-none">git branch -d [BRANCH_NAME]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>If you aren’t closing a Pull Request and find yourself needing to close a branch, you can use the following command to delete a branch on your  remote repository (again, likely on GitHub):</p><pre class="line-numbers language-none"><code class="language-none">git push --delete origin [BRANCH_NAME]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p>正常情况下，如果想要一个脱离主线的分支来开发项目，常常需要完全创建一个源代码目录的副本，对大项目来说，这样的过程会耗费很多时间，所以这是一个比较低效的做法。但是<strong>git分支则不同，你会发现使用分支和合并分支是非常方便的</strong>。</p><p>首先要知道<u><strong>git保存数据不是保存的文件的差异或变化</strong></u> ，而是一系列<u><strong>不同时刻</strong></u>( <u><strong>timelines</strong></u> )的<u><strong>文件快照</strong></u>（ <u><strong>snapshots</strong></u> ) 。<br>在进行提交操作时，Git会保存一个提交对象(blob对象)，该提交对象会包含一个指向暂存内容快照的指针，还包含作者的姓名,邮箱和提交时输入的信息以及指向它父对象的指针，首次提交时提交对象没有父对象，普通提交产生的提交对象有一个父对象，而由多个分支合并产生的提交对象 会有多个父对象。</p><p>这里举一个例子，假设现在工作目录中有三个将要被暂存和提交的文件，当使用git commit进行提交操作时，git会先计算每个子目录的校验和，然后在git仓库中为这些校验和保存为树对象，随后Git便会创建一个提交对象，它除了上面提到的那些信息外，还包含指向这个树对象的指针。现在仓库中有五个对象：三个blob对象（保存着文件快照）一个树对象（记录着目录结构和blob对象 索引）以及一个提交对象（包含着指向前述树对象的指针和所有提交信息）</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Branch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git_Basics</title>
      <link href="/posts/51b6a0f8/"/>
      <url>/posts/51b6a0f8/</url>
      
        <content type="html"><![CDATA[<h1 id="2-Git-Basics"><a href="#2-Git-Basics" class="headerlink" title="2.Git_Basics"></a>2.Git_Basics</h1><p>updated: 20/09/2021</p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>Git is used for tracking changes in source code during software development.<br><strong>It is designed for coordinating work amongst programmers, but <u>it can be used to track changes in any set of files</u>.</strong></p><blockquote><p>However, 所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p></blockquote><h2 id="Basic-Typical-Workflow"><a href="#Basic-Typical-Workflow" class="headerlink" title="Basic/Typical Workflow"></a>Basic/Typical Workflow</h2><p>The basic workflow for using Git:</p><ol><li><strong>Git clone</strong> - clone the source code you need to work on</li></ol><pre class="line-numbers language-none"><code class="language-none">git clone &lt;url&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li><strong>Git log</strong> - check the recent changes made to the project</li></ol><pre class="line-numbers language-none"><code class="language-none">git log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li><strong>Git branch / checkout</strong> - create a new branch to work on so that you don’t mess up with the project</li></ol><pre class="line-numbers language-none"><code class="language-none">git branch &lt;your branch name&gt;#or create branch and move to this branch immediately:git checkout -b &lt;your branch name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>You can use whatever editor you want; Git will track all the changes via checksums. Now that you made the necessary changes, it is time to put them on the <strong>staging area</strong>. As a reminder, the staging area is where you put modified codes that are ready to be <strong>snapshotted</strong>.</p><ol start="4"><li><strong>Git add</strong> - Stage </li></ol><pre class="line-numbers language-none"><code class="language-none">git add &lt;filename&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>You don’t have to add every file you modified to the staging area, only those which you want to be accounted in the snapshot</strong>. Now that the file is staged, it is time to “commit” it or putting its change in the database. We do this by using the command “commit” and <strong>attaching a little description</strong> with it.</p><ol start="5"><li><strong>Git commit</strong> - commit the change to database, but only on your computer!</li></ol><pre class="line-numbers language-none"><code class="language-none">git commit#orgit commit -m  &quot;&lt;message&gt;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><p>Show the code to the senior dev first before making a push. If they are okay with it, you can merge your branch with the main snapshot of the project (called the <del>master</del> main branch). So first you must navigate back to the main branch by using the “checkout” command.</p><hr><ol start="6"><li> Pull, Merge and Push: </li></ol><p>   <strong>6a)</strong>  <u>Switch to main branch</u></p>   <pre class="line-numbers language-none"><code class="language-none">git checkout master&#x2F;main<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>   You are now on the master branch, where all the team’s work is stored. <strong>But the time you worked on your fix, the project may have changed, meaning that a team member may have changed some files. You should retrieve those changes before committing your own changes to master.</strong> <strong>This will limit the risk of “conflicts” which can happen when two or more contributors change the same file.</strong> </p><p>   <strong>6b)</strong>  To get the changes, you have to <u>pull the project</u> from the remote server (also called <u>origin</u> ).</p>   <pre class="line-numbers language-none"><code class="language-none">Git pull origin master&#x2F;main<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>   <strong>6c)</strong>  Merge</p><p>   <strong>Conflicts only arise when the same line has been modified by multiple people. If you and your coworkers changed different parts of the file, everything is okay.</strong> Now that we kept up with the current state of the project, it’s time to commit our version to master. You can merge your branch with the “merge” command.</p>   <pre class="line-numbers language-none"><code class="language-none">git merge &lt;your branch name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>   6d) <strong>Push</strong></p><p>   Now that the commit has been merged back to master, it is time to push the changes to the main server. We do that by using to “push” command.</p>   <pre class="line-numbers language-none"><code class="language-none">git push<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><hr><h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><h3 id="Repositories"><a href="#Repositories" class="headerlink" title="Repositories"></a>Repositories</h3><p>A repository is a storage where all your project and all the changes made to it are kept. You can think of it as a “change database.” But don’t worry; it is only a normal folder on your system, so it is very easy to manipulate.</p><p>Open Git Bash:</p><pre class="line-numbers language-none"><code class="language-none">$ mkdir mynewproject$ cd mynewproject&#x2F;$ git init<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>mkdir is a command used to create a directory; it is short for “make directory.” cd is the command used to navigate between directories; it is short for “change directory.” Finally, git init is short for “Git initialize.”</p><blockquote><p><strong>mkdir and cd are system commands; they are managed by the OS;</strong><br><strong>whereas init is a Git command. Every Git command begins with “git.”</strong></p></blockquote><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/gitdirct.jpg" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><p>Instead of tracking changes between versions, Git <strong>takes snapshots</strong>. All those snapshots are stored in the “.git” directory. Each snapshot is called “commit”.<br><strong>The HEAD file in this “.git” directory points to the current “branch” or subversion of the project that you are working on.</strong> The default branch is called “<del>master</del> main,” but it is just like any other branch; the name is just an old convention.</p><h3 id="Working-Directory"><a href="#Working-Directory" class="headerlink" title="Working Directory"></a>Working Directory</h3><p>What about <strong>the empty area outside the “.git” directory</strong>? <strong>It is called the Working Directory</strong>, and the files you will be working on will be stored there. Generally, your most recent version will be on the Working Directory.</p><p>Each file you work on is on the Working Directory. There is nothing particular about this place except the fact that you will only manipulate the files here directly. <strong>Never modify the files inside the “.git” directory!</strong></p><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/workingdirc.jpg" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><p><strong>Git will detect any new file you will place in the Working Directory.</strong> <strong>And you check the status of the directory by using the Git command “status.”</strong></p><h3 id="Staging-Area"><a href="#Staging-Area" class="headerlink" title="Staging Area"></a>Staging Area</h3><p>The Staging Area is where your files go before the snapshots are taken.</p><pre class="line-numbers language-none"><code class="language-none">$ git add &lt;name_of_the_file&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>Unstage</strong> a file using the Git command “ <strong>git rm –cached</strong> ”</p><pre class="line-numbers language-none"><code class="language-none">$ git rm --cached &lt;name_of_the_file&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>Don’t forget ‘<strong>–cached</strong>‘ behind rm, otherwise you’ll <strong>lose your file</strong> !!!</p></blockquote><h3 id="Commits"><a href="#Commits" class="headerlink" title="Commits"></a>Commits</h3><p>A commit is just a <strong>snapshot</strong> of the <strong>entire project</strong> at a certain time. <u>Git doesn’t record the individual changes done to the files</u> ; it takes <u>a picture of the <strong>entire</strong> project</u> .</p><p>The previous state of the project is another commit called “parent.” The very first commit is created by Git when the repository is created, and it’s the one commit that has no parents. If a commit has two parents, that means that it was created by merging two branches.</p><p><strong>A reference to a specific commit is called “head,” and it also has a name. And the head you are currently working on is called “HEAD”.</strong></p><pre class="line-numbers language-none"><code class="language-none">git commit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="Further-Reading"><a href="#Further-Reading" class="headerlink" title="Further Reading"></a>Further Reading</h2><h3 id="Get-help-git-help-everyday"><a href="#Get-help-git-help-everyday" class="headerlink" title="Get help ( git help everyday )"></a><strong>Get help ( <u>git help everyday</u> )</strong></h3><p>This open a html on your default browser and you can check the manual of git.</p><h3 id="Username-and-Email-in-Git-Config-git-config"><a href="#Username-and-Email-in-Git-Config-git-config" class="headerlink" title="Username and Email in Git Config (git config)"></a>Username and Email in Git Config (git config)</h3><p>Setting Config Globally</p><pre class="line-numbers language-Git" data-language="Git"><code class="language-Git"># git config --global user.name &quot;[USERNAME]&quot;git config --global user.name &quot;bob-crutchley&quot;# git config --global user.email &quot;[EMAIL]&quot;git config --global user.email &quot;bob@email.com&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Setting Config Locally</p><pre class="line-numbers language-Git" data-language="Git"><code class="language-Git"># git config user.name &quot;[USERNAME]&quot;git config user.name &quot;bob-crutchley&quot;# git config user.email &quot;[EMAIL]&quot;git config user.email &quot;bob@email.com&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Forking"><a href="#Forking" class="headerlink" title="Forking"></a>Forking</h3><p>远程删除：</p><p>git remote -v 查看远程库信息</p><pre class="line-numbers language-Git" data-language="Git"><code class="language-Git">$ git remote -vorigin  git@github.com:michaelliao&#x2F;learn-git.git (fetch)origin  git@github.com:michaelliao&#x2F;learn-git.git (push)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>git remote rm <name> 比如 in this case ‘origin’:</p><pre class="line-numbers language-Git" data-language="Git"><code class="language-Git">$ git remote rm origin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Pull Request</p><p>让别人pull你写的东西。 </p><hr><blockquote><p>创建directory 或 进入directory - 这个directory文件夹就是你想要工作的文件夹</p><p>mkdir [dir_name]</p><p>cd [dir_name]</p></blockquote><h3 id="Staging-a-Change-git-add"><a href="#Staging-a-Change-git-add" class="headerlink" title="Staging a Change (git add)"></a><strong>Staging a Change (<em>git add</em>)</strong></h3><p><strong>Staging is the step that you must take before committing a change.</strong><br>Staging is a feature in Git that enables the developer to choose what changes are actually going to get committed to the repository when the commit is made. There is a few ways you stage files:</p><pre class="line-numbers language-Git" data-language="Git"><code class="language-Git"># stage all filesgit add --all# stage all files (only if you are at the root of your project)git add .# stage selected files: git add [FILES]git add file_1.txt file_2.txtgit add *.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Committing-a-Change-git-commit"><a href="#Committing-a-Change-git-commit" class="headerlink" title="Committing a Change (git commit)"></a><strong>Committing a Change (<em>git commit</em>)</strong></h3><p>When you make a commit to a Git repository, you are effectively “saving” the changes that you have staged to the repository.</p><p>Unlike saving files in most other programs, Git also requires <strong>a message</strong> to be saved against the commit along with some basic information about the user from the Git config shown above.</p><p>What you put in this message is important, <strong>so that you understand what it is that you changed on that particular commit</strong>.</p><blockquote><p>‘message’ here is like a ‘flag’ or ‘tag’, it is not the change you made in git add, it is just a reminder/sticker of what you have done.</p><p>commit的message是为了提醒你在git add里做的改动的总结/提醒/便签，并非是你要进行改动的内容</p></blockquote><p><strong>Commits can be reverted</strong>, so it helps when there is a concise message about what was implemented or removed.</p><hr><h4 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting:"></a><strong>Troubleshooting:</strong></h4><p>If getting ^X mode (^]^D^E^F^I^K^L^N^O^Ps^U^V^Y) at bottom of screen(whether it’s on Mac or Windows), it’s because the default text editor is <strong>vim</strong>. If you wish to use <strong>Nano</strong> you should type the following command:</p><pre class="line-numbers language-Git" data-language="Git"><code class="language-Git">git config --global core.editor &quot;nano&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h4 id="一图理解-git-add-与-index-与-stage-staging-联系"><a href="#一图理解-git-add-与-index-与-stage-staging-联系" class="headerlink" title="一图理解 git add 与 index 与 stage/staging 联系:"></a><strong>一图理解 git add 与 index 与 stage/staging 联系:</strong></h4><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/u=2451541123,1533082919&fm=26&fmt=auto.webp" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><p>Linus当年在维护Kernel的时候，他要研究每个Kernel的patch对Kernel到底有什么影响。例如，他有一个2.6.12的tarball，还有 patch-1，patch-2 两个，所以，他至少要弄出来三个新版本，2.6.12-patch1，2.6.12-patch2，2.6.12-patch1&amp;2。区区两个patch就搞出了3个新版本，如果patch多了不堪重负。</p><p>于是，他发明了一个“目录缓存（directory cache）”，其实就是现今git中的<strong>tree的概念</strong>，这个tree上的每个节点，都是一个Kernel的整个目录结构和文件（用一种高度压缩的形式表示的）。<strong>构建这个tree的方法，就是将内容添加到“缓存cache”，或者“更新缓存cache中的内容”</strong>。</p><p>用来存储这个树状结构的目录，叫“.dircache”（<strong>现在叫“.git”</strong>）。这个.git目录里，有个文件叫<strong>index</strong> (见下图），在git源码里（用C写的），操作这个index的各种变量名称，都有个前缀叫“cache”。<strong>这个index文件的作用，就是决定你要将什么文件，最终写入到那个树状结构里的，index就是暂存用的缓冲区。</strong>（可以看出来，这个树状结构，其根本作用就是维护海量的版本，其实就是git版本库本身了）（开发团队里的）每个人，都混用cache和index两个词，<strong>因为记录缓冲区（cache）内容的文件名，叫index</strong>。如果你给定文件路径，就能从index文件中找出来你要提交的内容（现在依旧如此）。</p><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/git_index.png" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><p>cached逐渐演变为形容词，表示要讨论的内容目前位于index文件中，而不是在工作目录（work directory）里面。（假如，我在工作目录里修改了一个文件，使用 git-add 命令，我修改的部分内容 —— 相当于一个patch —— 会在index里出现，但是在我的工作目录里，当然也还是有我修改的内容的，不过是叠加在版本库中的文件上的）。</p><p>在早期的时候，将“一个新文件添加到index里面”，和“更新一个index里面已经有的文件”，是两件不同的事情，但是，<strong>现在，已经统一起来了，都用 git-add 命令来操作</strong>。到这里，基本讲完了index的故事。<strong>因为index的添加和更新操作被统一起来了，所以，一些git的培训师，就将index这件事情，抽象成了一个叫做“下次提交的暂存区（staging area）”的东西</strong>，所以，将文件添加到index里面，也因此被叫做“to stage”，所以，stage这个词，是新近才出现在git的术语表里的。</p><hr><h3 id="Working-Repository-Status-git-status"><a href="#Working-Repository-Status-git-status" class="headerlink" title="Working Repository Status (git status)"></a><strong>Working Repository Status (git status)</strong></h3><p>Knowing the current state of your local repository is very useful so that you can understand what commands to run, especially when you are in the staging area.<br>For instance, <strong>how can you know what files have been staged and not staged</strong>?</p><pre class="line-numbers language-Git" data-language="Git"><code class="language-Git">git status<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="Abbreviations-Acronym"><a href="#Abbreviations-Acronym" class="headerlink" title="Abbreviations_Acronym"></a>Abbreviations_Acronym</h2><p>It’s not necessary to memorize these, but it helps you understand the command better.</p><blockquote><p>cd: change directory</p><p>pwd: print work directory</p><p>ls: list</p><p>mkdir: make directory</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Version_Control(VCS)&amp;Git</title>
      <link href="/posts/518e617c/"/>
      <url>/posts/518e617c/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Version-Control-VCS-amp-Git"><a href="#1-Version-Control-VCS-amp-Git" class="headerlink" title="1.Version_Control(VCS)&amp;Git"></a>1.Version_Control(VCS)&amp;Git</h1><p>Updated: 20/09/2021</p><h2 id="Version-Source-Control-版本控制"><a href="#Version-Source-Control-版本控制" class="headerlink" title="Version/Source Control 版本控制"></a>Version/Source Control 版本控制</h2><p>Version Control is about the management of multiple versions of a project. To manage a version, each change (addition, edition, or removal) to the files in a project must be tracked. Version Control records each change made to a file (or a group of files) and offers a way to undo or roll back each change.</p><p>Version control is vital for managing software development projects. Being able to track changes to code allows developers to:</p><ul><li>centralise all code changes and additions to one code repository</li><li>allow for simple and effective collaboration within development teams</li><li>control the integration of new code into the codebase</li><li>track changes from the entire team over the full lifetime of the project</li><li>revert code back to previous versions</li></ul><h3 id="VCS"><a href="#VCS" class="headerlink" title="VCS"></a>VCS</h3><p><strong>VCS: Version Control System</strong> .  A VCS <strong>tracks each change</strong> you made to every file of your project and provides a simple way to <strong>compare and roll back those changes</strong>.</p><p>Each version of the project is also accompanied by the description of the changes made along with a list of the new or edited files. When more people join the project, a VCS can show exactly who edited a particular file on a specific time. </p><hr><h2 id="Distributed-vs-Centralized-分布式-vs-集中式"><a href="#Distributed-vs-Centralized-分布式-vs-集中式" class="headerlink" title="Distributed vs Centralized 分布式 vs 集中式"></a>Distributed vs Centralized 分布式 vs 集中式</h2><h3 id="Centralized"><a href="#Centralized" class="headerlink" title="Centralized:"></a><strong>Centralized:</strong></h3><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/centralized.jpg" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/howcenworks2.jpg" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><hr><h3 id="Distributed"><a href="#Distributed" class="headerlink" title="Distributed:"></a><strong>Distributed:</strong></h3><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/distributed.jpg" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/howdisworks.jpg" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><p>A distributed Version Control System is generally faster than the other types of VCS because <strong>it doesn’t need a network access to a remote server</strong>. Nearly everything is done <strong>locally</strong>. There is also a slight difference with how it works: instead of tracking the changes between versions, it tracks all changes as “patches.” This means that those patches can be freely exchanged between repositories, so there is no “main” repository to keep up with.</p><p>Distributed VCS works nearly the same as centralized VCS but with a big difference: there is no main server that holds all the history. <strong>Each client has a copy of the repository(along with the change history) instead of checking out a single server.</strong><br>This greatly lowers the chance of losing everything as each client has a clone of the project. With a distributed VCS, the concept of having a “main server” gets blurred because each client essentially has all the power within their own repository. This greatly encouraged the concept of “forking” within the Open Source community. <strong>Forking is the act of cloning a repository to make your own changes and have a different take on</strong> <strong>the project</strong>. The main benefit of forking is that you could also pull changes from other repositories if you see fit (and others can do the same with your changes).</p><hr><h2 id="So-What-is-Git"><a href="#So-What-is-Git" class="headerlink" title="So What is Git?"></a>So What is Git?</h2><blockquote><p><strong>Git</strong> :</p><p><strong><u>Distributed</u></strong> <u><strong>Version Control</strong></u> System (Distributed VCS)</p><p><u><strong>分布式</strong> <strong>版本控制</strong></u> 系统</p></blockquote><p>I’m an egotistical bastard, and I name all my projects after myself. First Linux, now git. _Linus Torvalds</p><p>So basically Linus was pissed with BitKeeper(previous Linux VCS) and he decided to write a new open-sourced VCS. Hence the Git. <del>Too much drama, even for IT.</del></p><h3 id="Git-command-quick-review"><a href="#Git-command-quick-review" class="headerlink" title="Git command quick review"></a>Git command quick review</h3><pre class="line-numbers language-Git" data-language="Git"><code class="language-Git">$ git init # Initialize a new git database$ git clone # Copy an existing database$ git status # Check the status of the local project$ git diff # Review the changes done to the project$ git add # Tell Git to track a changed file$ git commit # Save the current state of the project to database$ git push # Copy the local database to a remote server$ git pull # Copy a remote database to a local machine$ git log # Check the history of the project$ git branch # List, create or delete branches$ git merge # Merge the history of two branches together$ git stash # Keep the current changes stashed away to be used later<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="Repositories-Short-for-Repo-仓库"><a href="#Repositories-Short-for-Repo-仓库" class="headerlink" title="Repositories (Short for Repo) 仓库"></a><strong>Repositories</strong> (Short for <strong><u>Repo</u></strong>) <strong>仓库</strong></h3><p>To keep code content in one place, VCS <strong>store code in a repository</strong>. This essentially functions as a big bucket for all your code to live in.</p><blockquote><p>repository /rɪˈpɒzətri/ 仓库; 贮藏室</p></blockquote><hr><h3 id="Branch-Merge-Stash"><a href="#Branch-Merge-Stash" class="headerlink" title="Branch /Merge/ Stash"></a>Branch /Merge/ Stash</h3><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/barnch,png.png" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><p>Branching allows for each developer to work on new features in isolation by creating a version of the source code that only they are working on.</p><p>This new version is called a feature branch, while the source code lives on the main branch.</p><p>Once changes have been made and the feature implemented, the feature branch code is merged back into the source code on the main branch.</p><p>The VCS will automatically detect the differences between the feature and main branches and alert the developer if there are any conflicts. </p><p>There is also a simple concept that you might use a lot: Stashing. Stashing is the act of safely putting away your current edits so that you have clean environment to work on something completely different. You might want to use stashing when you are playing around or testing a feature but need to work on a new feature in priority. So, you stash your changes away and begin to write that feature. After you are done, you can get your changes back and apply them to your current working environment.</p><hr><h2 id="Repository-Hosting-Services"><a href="#Repository-Hosting-Services" class="headerlink" title="Repository Hosting Services"></a><strong>Repository Hosting Services</strong></h2><p>There are several web-based version control <strong>repository hosting services</strong> out there:</p><ul><li><a href="https://github.com/">GitHub</a></li><li><a href="https://about.gitlab.com/">GitLab</a></li><li><a href="https://gitee.com/">Gitee</a></li><li>Bitbucket</li><li>SourceForge</li><li>Launchpad</li></ul><p>Many cloud providers have their own code repository offerings which offer simple and powerful integration with other cloud services:</p><ul><li>AWS CodeCommit</li><li><strong>Azure Repos (as part of Azure DevOps)</strong></li><li>Google Cloud Source Repositories</li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Repo </tag>
            
            <tag> Repositories </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DevOps_Part1</title>
      <link href="/posts/98993eff/"/>
      <url>/posts/98993eff/</url>
      
        <content type="html"><![CDATA[<h1 id="DevOps-Part-1"><a href="#DevOps-Part-1" class="headerlink" title="DevOps_Part 1"></a>DevOps_Part 1</h1><h2 id="How-Things-Used-to-be-Done"><a href="#How-Things-Used-to-be-Done" class="headerlink" title="How Things Used to be Done"></a>How Things Used to be Done</h2><p>Traditionally, software companies are structured as separate, stratified teams for <strong>development, quality assurance (sometimes known as testers), security, and operations</strong>.</p><p>These teams tend to have varying and sometimes conflicting goals and there is often poor communication between them, regularly resulting in work that is out of sync with other parts of the organisation. These isolated teams are referred to as <strong>silos</strong>.</p><blockquote><p>silo /ˈsaɪləʊ/  (农场储存草料、谷物等的)筒仓</p></blockquote><p> <img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/devopsvssiolos.png" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><hr><h2 id="How-DevOps-Changes-Things-Up"><a href="#How-DevOps-Changes-Things-Up" class="headerlink" title="How DevOps Changes Things Up"></a>How DevOps Changes Things Up</h2><p>There are two key elements to the DevOps approach that ensure that the methodology works: <strong>automation</strong> and <strong>measurement</strong>.</p><h3 id="Automation"><a href="#Automation" class="headerlink" title="Automation"></a><strong>Automation</strong></h3><p>A DevOps culture encourages automation in as many areas of the production pipeline as possible. <strong><u>As a rule of thumb: if a machine could do it, a machine should be doing it.</u></strong></p><h4 id="Continuous-Integration-CI-amp-Continuous-Deployment-Delivery-CD-持续集成-CI-amp-持续部署-CD"><a href="#Continuous-Integration-CI-amp-Continuous-Deployment-Delivery-CD-持续集成-CI-amp-持续部署-CD" class="headerlink" title="Continuous Integration (CI) &amp; Continuous Deployment/Delivery (CD) - 持续集成(CI) &amp; 持续部署(CD)"></a><strong>Continuous Integration (CI)</strong> &amp; Continuous Deployment/Delivery (CD) - 持续集成(CI) &amp; 持续部署(CD)</h4><h5 id="Continuous-Integration-CI-持续集成-CI"><a href="#Continuous-Integration-CI-持续集成-CI" class="headerlink" title="Continuous Integration (CI) - 持续集成(CI)"></a><strong>Continuous Integration (CI)</strong> - 持续集成(CI)</h5><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/continuousinte.png" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><ul><li>When code is committed to a repository, it is automatically built and subjected to acceptance tests.</li><li>Test failures result in the code being prevented from integrating  with the repository. Developers are immediately notified of a test  failure so they can fix issues as quickly as possible.</li></ul><hr><p><strong>Continuous Integration持续集成（CI），<u>是指在一段时间内（如：约定好的一天内或是一个上午），多次的将代码提交到主干上去</u>。自然，<u>每次都要通过测试</u>。</strong></p><p>大师Martin Fowler对持续集成是这样定义的:持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通常每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试)来验证，从而尽快地发现集成错误。许多团队发现这个过程可以大大减少集成的问题，让团队能够更快的开发内聚的软件。</p><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/ci2.png" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><p>为什么要使用持续集成？</p><ul><li>减少风险<br> 可以快速的发现错误</li><li>可快速定位错误</li><li>可降低代码整合的错误</li><li>防止长时间过后，集成失败</li><li>可以更好的了解进度，更好的收集数据</li></ul><p><strong>持续集成并不解决BUG，而是能够更加快速的发现以及更正。</strong></p><p><strong>自然地，当我们持续集成的时候，必须也要保证代码的可行性，简单讲就是单元测试通过了，我们才去集成</strong>。</p><h5 id="Continuous-Deployment-Delivery-CD-持续部署-交付-CD"><a href="#Continuous-Deployment-Delivery-CD-持续部署-交付-CD" class="headerlink" title="Continuous Deployment/Delivery (CD) - 持续部署/交付(CD)"></a>Continuous Deployment/Delivery (CD) - 持续部署/交付(CD)</h5><ul><li>As new code passes acceptance tests, it is automatically integrated into a deployment environment.</li><li>Being able to choose a version to deploy with one push a button requires a fair amount of automation.</li></ul><hr><p><strong>持续交付（Continuous delivery）CD 指的是，<u>频繁地将软件的新版本，交付给质量团队或者用户</u>。持续交付强调的是，<u>无论如何更新，都可以随时随地的交付软件的</u>。</strong></p><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/chixujiaofu1.png" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><p>持续部署（Continuous deployment）是持续交付的下一步，指的是代码通过评审以后，<u><strong>自动</strong>部署到生产环境</u> :</p><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/chixubushu.png" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><hr><p>Difference:</p><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/differencechi.png" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><hr><h3 id="Measurement"><a href="#Measurement" class="headerlink" title="Measurement"></a><strong>Measurement</strong></h3><p>Measurement is central to ensuring that a production pipeline is working efficiently.</p><p>The types of metrics we work to measure include：</p><h4 id="Frequency-of-deployments"><a href="#Frequency-of-deployments" class="headerlink" title="Frequency of deployments"></a>Frequency of deployments</h4><p>DevOps pipelines encourage frequent, smaller updates to software.</p><h4 id="Mean-time-to-Recovery-MTTR）"><a href="#Mean-time-to-Recovery-MTTR）" class="headerlink" title="Mean time to Recovery (MTTR）"></a>Mean time to Recovery (MTTR）</h4><p>This refers to <strong>the average time</strong> it takes to <strong><u>Solve problems</u></strong> that impact the end-user.</p><p>This is a more worthwhile metric than charting the frequency of failures as DevOps is less interested in minimising problems than the speed at which they are solved. </p><h4 id="Mean-time-to-Discovery-MTTD"><a href="#Mean-time-to-Discovery-MTTD" class="headerlink" title="Mean time to Discovery (MTTD)"></a>Mean time to Discovery (MTTD)</h4><p>This refers to <strong>how quickly</strong> problems are <strong><u>Discovered</u></strong>.</p><p>This metric is measured from the point of integration into production to the point the problem is identified. Naturally, faster MTTDs are more desirable.</p><h4 id="System-availability"><a href="#System-availability" class="headerlink" title="System availability"></a>System availability</h4><h4 id="Service-performance"><a href="#Service-performance" class="headerlink" title="Service performance"></a>Service performance</h4><hr><h2 id="Additional-Reading"><a href="#Additional-Reading" class="headerlink" title="Additional Reading"></a>Additional Reading</h2><p>Mandarin: <a href="https://www.cnblogs.com/xiugeng/p/10555847.html">https://www.cnblogs.com/xiugeng/p/10555847.html</a></p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scrum</title>
      <link href="/posts/67fd1987/"/>
      <url>/posts/67fd1987/</url>
      
        <content type="html"><![CDATA[<h1 id="Scrum"><a href="#Scrum" class="headerlink" title="Scrum"></a>Scrum</h1><blockquote><p>Little freshen up:</p><p>Scrum is one of the Agile development framework. Others : Kanban, XP.</p><p>Agile is more like a development method, while Scrum is one way/framework to implement it.</p></blockquote><h2 id="Scrum-1"><a href="#Scrum-1" class="headerlink" title="Scrum"></a>Scrum</h2><p>The <strong>scrum/skrʌm/</strong> framework is <strong>iterative</strong> and will <u>produce a potentially <strong>shippable</strong> increment at the end of every sprint</u>. A potentially shippable increment means that it will add functionality on what was there previously, therefore adding value. The additional code should be “shippable” (it shouldn’t be half broken, it should be ready to distribute).</p><hr><h2 id="What-is-a-Sprint"><a href="#What-is-a-Sprint" class="headerlink" title="What is a Sprint?"></a>What is a Sprint?</h2><p>A sprint is <strong>a time-boxed event</strong> in which everything happens.<br>This could be anywhere between one week and four weeks. </p><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/sprint.jpeg" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><h3 id="Product-Backlog-产品列表"><a href="#Product-Backlog-产品列表" class="headerlink" title="Product Backlog  / 产品列表"></a><strong><u>Product</u> Backlog</strong>  / 产品列表</h3><p>The Product Backlog is an ordered list of all features, enhancements and fixes to be made to the product in future releases.</p><blockquote><p><strong>产品列表  / Product Backlog：根据用户价值进行优先级排序的高层需求</strong></p></blockquote><p><strong><u>The Product Owner</u></strong> is <strong>responsible</strong> for the <strong>Product Backlog</strong>, including its content, availability, and ordering.</p><blockquote><p><strong>产品负责人 / Product Owner： 负责维护产品订单的人，代表利益相关者的利益。</strong></p><p><strong>Scrum主管 / Scrum Master： 为Scrum过程负责的人，确保scrum的正确使用并使得Scrum的收益最大化。</strong></p></blockquote><p>The development team will collaborate with the Product Owner in adding details where necessary.</p><p>Product Backlog items have the attributes of a description, order, estimate, and value.</p><p>Product Backlog items often include test descriptions that will prove its completeness when “Done”.</p><h3 id="Sprint-Backlog-冲刺订单"><a href="#Sprint-Backlog-冲刺订单" class="headerlink" title="Sprint Backlog / 冲刺订单"></a><strong><u>Sprint</u> Backlog</strong> / 冲刺订单</h3><p>The Sprint Backlog is the set of Product Backlog items selected for the Sprint.</p><blockquote><p><strong>冲刺订单 Sprint Backlog：要在冲刺中完成的任务的清单</strong></p></blockquote><p>The Sprint Backlog makes visible all the work that the Development Team identifies as necessary to meet the Sprint Goal.</p><p>As work is worked on it moves through the workflow. The workflow usually has a minimum of three stages, “To be completed”, “In progress” and “Done”.</p><hr><h2 id="Scrum-Roles"><a href="#Scrum-Roles" class="headerlink" title="Scrum Roles"></a>Scrum Roles</h2><p><strong>Project Manager (PM)</strong></p><p>PM’s manage projects and will overview expenses. They will also try to reduce risk on the project</p><p><strong>Product Owner (PO)</strong></p><p>PO’s are the sole person responsible for managing the Product Backlog (i.e. the list of features to be worked on).</p><p><strong>Business Analyst (BA)</strong></p><p>Support the product owner by gathering requirements, provide guidance on what to build. They usually work across many products.</p><p><strong>Development Team</strong></p><p>A multi-disciplinary team usually comprised of software architects, designers, programmers and testers.</p><p><strong>Scrum Master (SM)</strong></p><p>Facilitates Scrum. The scrum master helps those outside the scrum team understand which interactions are beneficial. The scrum masters services the development team by removing impediments, facilitates meetings and coaches in self-organisation</p><hr><h3 id="Additional-Reading-Differences-between-Scrum-Master-and-Project-Manager"><a href="#Additional-Reading-Differences-between-Scrum-Master-and-Project-Manager" class="headerlink" title="Additional Reading - Differences between Scrum Master and Project Manager"></a>Additional Reading - Differences between Scrum Master and Project Manager</h3><p><strong>Scrum Master vs Project Manager</strong></p><p>English: <a href="https://medium.com/the-value-maximizers/scrum-master-vs-project-manager-an-overview-of-the-differences-73104d0264ab">https://medium.com/the-value-maximizers/scrum-master-vs-project-manager-an-overview-of-the-differences-73104d0264ab</a></p><p>Mandarin: <a href="https://www.jianshu.com/p/50687f8d5a6e">https://www.jianshu.com/p/50687f8d5a6e</a></p><hr><h2 id="Scrum-Meetings"><a href="#Scrum-Meetings" class="headerlink" title="Scrum Meetings"></a>Scrum Meetings</h2><p>There are four different key meetings which take place in the sprint and are discussed in this module.</p><p>These meetings are:</p><pre><code>Sprint Planning MeetingDaily StandupSprint Review MeetingSprint Retrospective Meeting</code></pre><blockquote><p>计划会 / Sprint Planning Meeting：在每个冲刺之初，由产品负责人讲解需求，并由开发团队进行估算的计划会议。</p><p>每日立会 / Daily Standup Meeting：团队每天进行沟通的内部短会，因一般只有15分钟且站立进行而得名。</p><p>评审会 / Review Meeting：在冲刺结束前给产品负责人演示并接受评价的会议。</p><p>反思会/回顾会 / Retrospective Meeting：在冲刺结束后召开的关于自我持续改进的会议。</p></blockquote><hr><h2 id="Product-Backlog-Items-PBI"><a href="#Product-Backlog-Items-PBI" class="headerlink" title="Product Backlog Items (PBI)"></a>Product Backlog Items (PBI)</h2><p>产品待办项/产品任务列表（Product Backlog Item/<strong>PBI</strong>）是可以预知的所有任务，包括功能性的和非功能性的任务，PBI属于计划阶段，指出了我们目标.</p><p>The most common type of Product Backlog Item (PBI) is a <strong>User Story</strong>.<br>They are however multiple forms an item can take and they are:</p><ul><li>User stories</li><li>Use cases</li><li>Bugs, errors and fixes</li><li>Constraints</li></ul><h3 id="User-Story"><a href="#User-Story" class="headerlink" title="User Story"></a>User Story</h3><h4 id="User-Story-1"><a href="#User-Story-1" class="headerlink" title="User Story"></a>User Story</h4><p>A user story is an end goal expressed from the user’s perspective.</p><ul><li>Focuses on <u>what they want to do</u> rather than how to do it</li><li>These users <u>can be external or internal</u></li><li>They should be expressed <u>in simple language that everyone can understand</u></li></ul><hr><h5 id="用户故事-user-story"><a href="#用户故事-user-story" class="headerlink" title="用户故事(user story)"></a>用户故事(user story)</h5><p><strong>一件用户通过系统完成他一个有价值的目标的事。</strong></p><p>什么是用户故事(user story)<br>    假定这个项目的客户是个饮料自动售货机的制造商。他们要求我们为他们的售货机开发一款软件。我们可以找他们的市场经理了解这个软件的需求。<br>    因此，我们的客户就是他们的市场经理。谈需求的时候，有一回他这样说：“用户往售货机每塞一个硬币，售货机都要显示当前该客户已经投了多少钱。当用户投的钱够买某一款饮料时，代表这款饮料的按钮的灯就会亮。如果那个用户按了这个按钮，售货机就放一罐饮料到出口，然后找零钱给他。”<br>    上面的话描述的是一件事情，一件用户通过系统完成他一个有价值的目标（买一罐饮料）的事。这样的过程就叫“用户案例(user case)”或者“用户故事(user story)”。也就是说，上面我们的客户所说的话，就是在描述一个用户故事（user story）。<br>    (我解释一下为什么用故事这个词，没兴趣也可以忽略。在一个系统面前，每个用户要完成同样的目标，都要做这个系统设定的例行的事，这件事情不是一个例子，所以不叫事例，这也不是故事，也不能算一段历程，而是一个例行的事。)<br>    如果我们想要记下这段用户故事，我们可能会用这样的格式：<br>    名称：卖饮料<br>    事件：</p><pre><code>1. 用户投入一些钱。    2. 售货机显示用户已经投了多少钱。    3. 如果投入的钱足够买某种饮料，这种饮料对应的按钮的灯就会亮。    4. 用户按了某个亮了的按钮。    5. 售货机卖出一罐饮料给他。    6. 售货机找零钱给他。    注意到，一个用户故事里面的事件可以这样描述：    1. 用户做XX。    2. 系统做YY。     3. 用户做ZZ。    4. 系统做TT。    5.  ... </code></pre><p><u><strong>用户故事只是描述系统的外在行为</strong></u></p><p>一个用户故事只是以客户能够明白的方式，描述了一个系统的外在行为，它完全忽略了系统的内部动作。比如，下面有下划线的那些文字，就属于不应该出现在用户故事中的系统内部动作：</p><p>  \1. 用户投入一些钱。</p><p>  \2. 售货机将塞进来的钱存在钱箱里，然后发送一条命令给屏幕，屏幕显示目前已经投入的金额。</p><p>  \3. 售货机查询数据库里面所有饮料的价格，判定钱足够买哪些饮料，对于钱足够买的那些饮料，对应的按钮的灯就会亮起来。</p><p>  \4. 用户按下一个亮起来的按钮。</p><p>  \5. 售货机卖出一罐饮料给用户，然后将数据库里面该饮料的存货数量减1。</p><p>  \6. 售货机找零钱给用户。</p><p>  不管是口头描述的，还是书面形式，这样的内容是描述用户故事时一个很常见的错误。特别的，千万不要提及任何有关数据库，记录，字段之类的对客户一点意义都没有的东西。</p><hr><h4 id="Epic-User-Stories-Tasks"><a href="#Epic-User-Stories-Tasks" class="headerlink" title="Epic, User Stories, Tasks"></a>Epic, User Stories, Tasks</h4><p>An <strong>Epic</strong> is made up of multiple user stories.</p><p>A User story is made up of multiple <strong>Task</strong>s.</p><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/userst.png" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/dffd8d011d55eb8a.png" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><hr><h3 id="DOR-DOD"><a href="#DOR-DOD" class="headerlink" title="DOR DOD"></a><strong>DOR DOD</strong></h3><p><strong>Definition of Ready (DoR)</strong></p><p>Definition of Ready (DoR) defines what a product backlog item needs before it can go into the sprint backlog. </p><p>Checklist:</p><ul><li>Technical details have been discussed on the item and agreed</li><li>Assigning a priority</li><li><strong>Timing Estimates</strong></li></ul><p><strong>Definition of Done (DoD)</strong></p><p>Definition of Done (DoD) defines what is needed before it can be regarded as complete. A definition of done can be applied to a feature, a sprint or a release.</p><p>Checklist:</p><ul><li>Unit testing written and passed.</li><li>Documentation updated</li><li>Peer code review completed</li></ul><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/f2449d468bd7ab0a.png" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><hr><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a><strong>Summary</strong></h3><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/definition-of-ready.webp" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><hr><h2 id="Risk-Assessments"><a href="#Risk-Assessments" class="headerlink" title="Risk Assessments"></a>Risk Assessments</h2><h4 id="Control-Measures"><a href="#Control-Measures" class="headerlink" title="Control Measures"></a>Control Measures</h4><p>When planning control measures, one of the following three solutions may be drawn:</p><ol><li><code>Mitigation</code> - decreasing the likelihood of the hazard’s occurrence, or the impact it would have on the project</li><li><code>Acceptance</code> - sometimes it can be too costly to mitigate the risk in comparison to the impact it would have on the project, in  which case we may choose to do nothing</li><li><code>Transfer</code> - assigning the risk to a third party, usually in the form of an insurance policy</li></ol><h4 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h4><p>In general they should have each of the following elements:</p><ul><li><code>Description</code> - what is the scenario?</li><li><code>Evaluation</code> - what would happen if this scenario occurred?</li><li><code>Likelihood</code> - how likely is it to occur?</li><li><code>Impact Level</code> - how devastating to the project would it be if this occurred?</li><li><code>Responsibility</code> - who’s responsibility is it to mitigate this risk?</li><li><code>Response</code> - what would we do if the scenario occurred?</li><li><code>Control Measures</code> - what can we do to decrease the likelihood and/or impact?</li></ul><hr><h2 id="Estimations"><a href="#Estimations" class="headerlink" title="Estimations"></a>Estimations</h2><p>In scrum we use <strong><u>Story Points</u></strong> as to estimate <strong><u>the Amount of</u></strong> work needed to complete a task.</p><p>A story point is a unitless measurement. It is the relative difference which are important.</p><p><strong><u>TIME IS NOT USED</u> TO ESTIMATE WORK</strong>:</p><blockquote><p>Time based estimates don’t work because an hour’s work will vary drastically between developers, so it becomes a bad measurement for predicting amount of work. It is easier for developers to agree on relative amounts of work. </p></blockquote><h3 id="Burndown-Charts"><a href="#Burndown-Charts" class="headerlink" title="Burndown Charts"></a>Burndown Charts</h3><p>By estimating all the tasks done, when they are completed throughout the sprint, <strong>the amount of work left will decrease</strong>. This can be outputted to a graph known as a burndown chart.</p><p><strong>They all for team visibility on progress.</strong></p><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/burndownchart.png" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><hr><h2 id="Prioritisation-using-MoSCoW"><a href="#Prioritisation-using-MoSCoW" class="headerlink" title="Prioritisation using MoSCoW"></a>Prioritisation using MoSCoW</h2><p>The MoSCoW method is a popular prioritisation techinque used for managing requirements.</p><p>It is important to work with stakeholders to determine the importance of each component of the requirements in order to guarantee a <strong>minimum viable product (MVP)</strong> is achieved. </p><p>一般在迭代计划会上使用MoSCoW方法进行这种排序，将要Sprint Backlog中的条目分为四级（其实只有前3级）：<br>Must：必须做的；<br>Shoud：应该做的；<br>Could：可以做的；<br>Would not：不要做的。</p><p>如果使用故事墙Story Wall进行管理，最好也按M、S、C（W其实不会出现）三个级别排放待开发的故事，优先拿M，最后动C。如果愿意，可以用三种颜色的便签纸来表示，防止M、S完成前就有人动C。</p><p>MoSCoW只是对Sprint Backlog的排序方法.</p>]]></content>
      
      
      <categories>
          
          <category> Agile </category>
          
          <category> Software Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Agile </tag>
            
            <tag> Scrum </tag>
            
            <tag> Software Development </tag>
            
            <tag> Project Management </tag>
            
            <tag> Sprint </tag>
            
            <tag> Epic </tag>
            
            <tag> User Story </tag>
            
            <tag> Story Point </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Agile</title>
      <link href="/posts/b6d6088d/"/>
      <url>/posts/b6d6088d/</url>
      
        <content type="html"><![CDATA[<h1 id="Agile-敏捷项目管理"><a href="#Agile-敏捷项目管理" class="headerlink" title="Agile  敏捷项目管理"></a>Agile  敏捷项目管理</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>Agile/ˈædʒaɪl/ is the most common <strong>software development</strong> methodology - it is an <strong>iterative</strong>(/‘ɪtərətɪv/<strong>迭代式</strong>) methodology to create software. The simplest and oldest methodology however is the waterfall methodology. The waterfall methodology had some disadvantages which led most companies to adopt the new agile methodology. Both methodologies use the Software Development Lifecycle (SDLC) but implement it in different ways.</p><p><strong>Software Development Lifecycle(SDLC)</strong></p><p>The software development lifecycle is the steps necessary to create any piece of software. It is made up of 6 separate stages: <strong>Requirements, Analysis, Design, Coding, Testing and Operation</strong></p><blockquote><p><code>Although Agile seems to be the most popular software development methodology now, it doesn&#39;t mean Waterfall methodology is out-dated or has no advantage. For example, if you are trying to build a bridge, do you really want to build a MVP(Minimum Viable Product) first then improve it? The answer is definitely no. You would want build it to a certain standard considering the safety issues and many other problems. So the waterfall would be a better fit in this case.</code></p></blockquote><hr><h2 id="Waterfall-vs-Agile"><a href="#Waterfall-vs-Agile" class="headerlink" title="Waterfall vs Agile"></a>Waterfall vs Agile</h2><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/v2-12223b04c233f2e0ad86123e5aec446a_1440w.jpg" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><hr><h2 id="Agile-Values-Manifesto-敏捷软件开发宣言"><a href="#Agile-Values-Manifesto-敏捷软件开发宣言" class="headerlink" title="Agile Values / Manifesto 敏捷软件开发宣言"></a>Agile Values / Manifesto <strong>敏捷软件开发宣言</strong></h2><ol><li><p><strong><u>Individuals and Interactions</u> over Processes and Tools</strong></p><p><strong><u>个体和互动</u>  高于  流程和工具</strong></p></li><li><p><strong><u>Working Software</u> over Comprehensive Documentation</strong></p><p><strong><u>可工作的软件</u> 高于 详尽的文档</strong></p></li><li><p><strong><u>Customer Collaboration</u> over Contract Negotiation</strong></p><p><strong><u>客户协作</u>  高于  合同谈判</strong></p></li><li><p><strong><u>Responding to Chang</u>e over Following a Plan</strong></p><p><strong><u>响应变化</u> 高于 遵循计划</strong></p></li></ol><hr><h2 id="Agile-Principles-工作原则"><a href="#Agile-Principles-工作原则" class="headerlink" title="Agile Principles 工作原则"></a>Agile Principles 工作原则</h2><ol><li>​    Our highest priority is to satisfy the customer through early and continuous delivery of valuable software.</li><li>​    Welcome changing requirements, even late in development. Agile processes harness change for the customer’s competitive advantage.</li><li>​    Deliver working software frequently, from a couple of weeks to a couple of months, with a preference to the shorter timescale.</li><li>​    Business people and developers must work together daily throughout the project.</li><li>​    Build projects around motivated individuals. Give them the environment and support they need, and trust them to get the job done.</li><li>​    The most efficient and effective method of conveying information to and within a development team is face-to-face conversation.</li><li>​    Working software is the primary measure of progress.</li><li>​    Agile processes promote sustainable development. The sponsors, developers, and users should be able to maintain a constant pace indefinitely.</li><li>​    Continuous attention to technical excellence and good design enhances agility.</li><li>​    Simplicity - the art of maximising the amount of work not done is essential.</li><li>​    The best architectures, requirements, and designs emerge from self-organising teams.</li><li>​    At regular intervals, the team reflects on how to become more effective, then tunes and adjusts its behaviour accordingly.</li></ol><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/v2-c15cd51c61a48138cd4b17579081cf12_1440w.jpg" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><h2 id="Empirical-Process-Control"><a href="#Empirical-Process-Control" class="headerlink" title="Empirical Process Control"></a>Empirical Process Control</h2><blockquote><p>empirical /ɪmˈpɪrɪkl/ 经验主义的</p></blockquote><ol><li>Transparency</li><li>Inspection</li><li>Adaptation</li></ol><h2 id="Scrum-and-other-Common-Agile-development-frameworks"><a href="#Scrum-and-other-Common-Agile-development-frameworks" class="headerlink" title="Scrum and other Common Agile development frameworks"></a>Scrum and other Common Agile development frameworks</h2><blockquote><p><strong>Scrum /skrʌm/</strong>  (英式橄榄球)并列争球，密集争球 In rugby, a scrum is a tight group formed by players from both sides pushing against each other with their heads down in an attempt to get the ball.</p></blockquote><p>Scrum is the most common Agile development framework, others are <strong>Kanban</strong>, XP (eXtreme Programming).</p><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/000.png" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><h2 id="Related-concept-that-might-help-you-understand-the-term-“Working-software”"><a href="#Related-concept-that-might-help-you-understand-the-term-“Working-software”" class="headerlink" title="Related concept that might help you understand the term “Working software”:"></a>Related concept that might help you understand the term “Working software”:</h2><p>The term ‘Working Software’ is kind of like the concept of Minimum Viable Product(MVP) - you build something primitive that actually <strong>work</strong> (may not be perfect) - get feedback - improve it - get feedback -improve it…. :</p><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/J5LPsyNvGP67SQgew229.webp" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p>]]></content>
      
      
      <categories>
          
          <category> Agile </category>
          
          <category> Software Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Agile </tag>
            
            <tag> Scrum </tag>
            
            <tag> Software Development </tag>
            
            <tag> Project Management </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>What is SMB?</title>
      <link href="/posts/34b77a68/"/>
      <url>/posts/34b77a68/</url>
      
        <content type="html"><![CDATA[<h1 id="What-is-SMB"><a href="#What-is-SMB" class="headerlink" title="What is SMB?"></a>What is SMB?</h1><h2 id="SMB-amp-SMB-compliant"><a href="#SMB-amp-SMB-compliant" class="headerlink" title="SMB &amp; SMB-compliant"></a>SMB &amp; SMB-compliant</h2><h3 id="SMB"><a href="#SMB" class="headerlink" title="SMB"></a>SMB</h3><p><strong><u>Server Message Block</u></strong> (<strong>SMB</strong>), one version of which was also known as <u><strong>Common Internet File System</strong></u> (<strong>CIFS</strong> /sɪfs/), is a <strong><u>communication protocol</u></strong> for providing <strong><u>shared access to files, printers, and serial ports between nodes on a network</u></strong>. It also provides an authenticated inter-process communication (IPC) mechanism. Most usage of SMB involves computers running <strong>Microsoft Windows</strong>, where it was known as “Microsoft Windows Network” before the introduction of Active Directory. Corresponding Windows services are LAN Manager Server for the server component, and LAN Manager Workstation for the client component.</p><h3 id="Samba"><a href="#Samba" class="headerlink" title="Samba"></a>Samba</h3><p>In 1991 Andrew Tridgell started the development of Samba, a <strong>free-software</strong> re-implementation (using reverse engineering) of the <strong>SMB/CIFS networking protocol for Unix-like systems</strong>, initially to implement an SMB server to allow PC clients running the DEC Pathworks client to access files on SunOS machines. Because of the importance of the SMB protocol in interacting with the widespread Microsoft Windows platform, <strong>Samba became a popular free software implementation of a compatible SMB client and server to allow non-Windows operating systems, such as Unix-like operating systems, to interoperate with Windows.</strong> </p><h3 id="什么是SMB"><a href="#什么是SMB" class="headerlink" title="什么是SMB"></a>什么是SMB</h3><p><strong>SMB</strong>(全称是 <strong><u>Server Message Block</u></strong> )是一个<strong>协议名</strong>，它能 <strong><u>被用于Web连接和客户端与服务器之间的信息沟通</u></strong> 。SMB最初是IBM的贝瑞·费根鲍姆（Barry Feigenbaum）研制的，其目的是将DOS操作系统中的本地文件接口“中断13”改造为网络文件系统。</p><h4 id="研究背景"><a href="#研究背景" class="headerlink" title="研究背景"></a>研究背景</h4><p>随着网络通信技术和网络资源共享机制的不断发展，针对网络间支持数据共享的协议和机制等技术的研究受到了研究人员的广泛关注。其中，网络文件共享传输过程的安全性研究更是成为该领域的热点问题。其中，SMB（ServerMessageBlock）协议作为一种局域网文件共享传输协议，常被用来作为共享文件安全传输研究的平台。但是，SMB协议中采用控制文件安全传输的机制是使用客户身份验证的方式，该方式通过客户端向服务器端发送验证密码来获取文件传输的权限，不过针对该机制的网络攻击相对严重，攻击程序通过对验证密码的截获来窃取文件的访问权限，局域网下文件传输的安全性得不到保障.</p><h4 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h4><p>SMB协议可以为局域网用户提供相关的功能和机制，来保证传输的可靠性。局域网中90%的数据包以及95%的字节是通过SMB协议进行传输，这是为了解决网络的稳定性和数据流在共享带宽时的公平性、拥塞控制及效率等问题。由于SMB传输应用的普遍性和重要性，关于SMB传输这一课题计算机领域中很多学者致力于这一方面潜心研究，就SMB协议及其多个版本在各类网络下的传输效率问题做了大量的研究和实验。在局域网发展之初该网内的文件共享是通过FTP协议进行传输。用户必须首先从服务器下载该文件的数据到本地（客户端），然后对数据文件进行修改操作，之后，用户重新将客户端的文件上传到FTP服务器中，但是用户不能直接对FTP上的数据信息等进行修改操作。如果用户在该过程中对文件进行了修改操作，但并没有将修改后的文件上传到FTP服务器，那么之后申请读取该文件的用户就无法下载最新的文件。</p><p>1984年，安德鲁Tridgwell曾遇到这样的问题，他用三台个人电脑都运行DOS系统，通过电脑计算机DEC的Unix数字系统以及Sun公司的Unix系统进行试验。当时，安德鲁Tridgwell写了一个程序，以检测通信协议在DEC的Unix系统下计算机处理哪些信息，在信息传输过程中，对程序中的相关参数进行更改，便可读取来自不同计算机的信息文件等内容，进而实现了计算之间的信息数据的互通。通过这种方式他们发现了一种可以进行操作系统之间信息通信的协议，并在此协议的基础上进行改进，将改进后的协议命名为SMB协议，该协议的文件传输系统可以实现不同操作系统间文件和信息的共享。在这之后，安德鲁Tridgwell开始应用SMB服务器作为软件的注册商标。这是SMB的由来。为了能够在不同的Windows主机设备之间实现共享文件数据的目的，便出现了更高版本的SMB协议。但最常见的（在Windows98，WindowsNT中，Windows2000和XP）是NTLM0.12版本。SMB协议可以实现相邻网络中间的计算机中文件的共享功能，该协议包含两部分分别是服务器端和客户端，它通过网络中的TCP、NetBEUI等通信协议建立会话连接，然后用户可以通过该协议的客户端发起文件共享请求，并通过服务器接收到的请求将文件发送给用户来实现文件的共享。</p><p>SMB1.0协议由于在文件共享传输过程中存在的传输效率低以及传输空间小等缺陷被人们所摒弃。为了更好的实现网络中文件的共享过程，在SMB1.0的基础上开发了新的网络文件传输协议，并将其命名为SMB2.0。该协议在实现了文件共享传输的基本功能的基础上对文件传输的效率、文件缓存的空间以及文件并发传输等问题进行改进，使得在局域网或更高配置的网络环境下，文件传输过程的速度和效率等得到了很大的提升。并且，由于对于SMB研究领域已经出现了可以对该文件共享过程进行信息截取等恶意攻击方法，故而在SMB版本更新的过程中加入了对文件传输过程的安全性保障机制。在对SMB协议的研究过程中，很多文献均选择对文件传输效率等问题进行改进，但是对该协议的本质内容并没有做改变，其主要原因是SMB协议自身的复杂性和其对操作系统的依赖性。但是，正是由于SMB依赖于操作系统等底层的架构，所以对于文件的传输等过程的控制和性能提升等操作可以通过它所依赖的底层系统来进行修改，进而达到对文件传输过程的控制和优化。</p><h4 id="SMB协议"><a href="#SMB协议" class="headerlink" title="SMB协议"></a>SMB协议</h4><p>后来微软对这个发展进行了重大更改，这个更改后的版本也是最常见的版本。微软将SMB协议与它和3Com一起发展的网络管理程序结合在一起，并在Windows for Workgroups和后来的Windows版本中不断加入新的功能。<br>SMB一开始的设计是在NetBIOS协议上运行的（而NetBIOS本身则运行在NetBEUI、IPX/SPX或TCP/IP协议上），Windows 2000引入了SMB直接在TCP/IP上运行的功能。在这里我们必须区分SMB协议和运行在这个协议上的SMB业务，以及NetBIOS和使用SMB作为认证隧道的DCE/RPC业务。此外我们还要区分主要（但不仅仅）直接使用NetBIOS数据报的“网络邻居”协议。<br>1996年，Sun推出WebNFS的同时，微软提出将SMB改称为Common Internet File System。此外微软还加入了许多新的功能，比如符号链接、硬链接、提高文件的大小。微软还试图支持直接联系，不依靠NetBIOS，不过这个试图依然处于尝试阶段，并需要继续完善。微软向互联网工程工作小组提出了部分定义作为互联网草案[3]。不过这些提案均已过期。<br>由于SMB协议对于与占主要地位的Microsoft Windows平台通讯时的重要性，而该平台使用的SMB协议与初始的版本相比有巨大的改变，因此Samba项目就是被创立来逆向工程来提供一个与SMB软件兼容的自由软件，使得非微软操作系统也能够使用它。<br>在Windows Vista中微软又推出了Server Message Block 2.0。</p><h4 id="SMB3-0"><a href="#SMB3-0" class="headerlink" title="SMB3.0"></a>SMB3.0</h4><p>服务器信息块（SMB）是一个网络文件共享协议，它允许应用程序和终端用户从远端的文件服务器访问文件资源。微软最初将SMB定位为Windows Server 2008和Vista系统中通用互联网文件系统（CIFS）的后续产品。最新版本的SMB 3.0在Windows Server 2012操作系统中出现，并且与Windows 8客户端共同工作。<br>SMB 3.0极大的提升了性能、可靠性和安全性。具体来说，当它与Windows Storage Spaces（Windows Server 2012的一个功能，将普通的硬盘虚拟化为高性能、高可用性的存储）结合时，SMB 3.0可以使用廉价的直连存储（DAS）、JBOD或RBOD，创建一个特定的NAS设备（或SAN存储阵列）。IT组织可以因此在不购买昂贵的SAN存储的情况下得到企业级存储的特性，而且管理也变得更加简单。此外，SMB 3.0支持一些以前只在块存储环境下才可以使用的应用程序，如SQL Server。</p><h4 id="IBM-SMB"><a href="#IBM-SMB" class="headerlink" title="IBM SMB"></a>IBM SMB</h4><p><strong>（IBM SMB：Server Message Block protocol）</strong><br><strong>服务器信息块（SMB）协议是一种IBM协议，用于在计算机间共享文件、打印机、串口等。SMB 协议可以用在因特网的TCP/IP协议之上，也可以用在其它网络协议如IPX和NetBEUI 之上。</strong><br><strong>SMB 一种客户机/服务器、请求/响应协议。通过 SMB 协议，客户端应用程序可以在各种网络环境下读、写服务器上的文件，以及对服务器程序提出服务请求。此外通过 SMB 协议，应用程序可以访问远程服务器端的文件、以及打印机、邮件槽（mailslot）、命名管道（named pipe）等资源。</strong><br><strong>在 TCP/IP 环境下，客户机通过 NetBIOS over TCP/IP（或 NetBEUI/TCP 或 SPX/IPX）连接服务器。一旦连接成功，客户机可发送 SMB 命令到服务器上，从而客户机能够访问共享目录、打开文件、读写文件，以及一切在文件系统上能做的所有事情。</strong><br><strong>从 Windows 95 开始，Microsoft Windows 操作系统（operating system）都包括了客户机和服务器 SMB 协议支持。Microsoft 为 Internet 提供了 SMB 的开源版本，即通用 Internet 文件系统 （CIFS）。与现有 Internet 应用程序如文件传输协议（FTP）相比， CIFS 灵活性更大。对于 UNIX 系统，可使用一种称为 Samba 的共享软件。</strong></p><h2 id="References"><a href="#References" class="headerlink" title="References:"></a>References:</h2><p><a href="https://en.wikipedia.org/wiki/Server_Message_Block">https://en.wikipedia.org/wiki/Server_Message_Block</a></p><p><a href="https://baike.baidu.com/item/smb/4750512?fr=aladdin">https://baike.baidu.com/item/smb/4750512?fr=aladdin</a></p>]]></content>
      
      
      <categories>
          
          <category> Azure </category>
          
          <category> Data Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Azure </tag>
            
            <tag> Data Storage </tag>
            
            <tag> SMB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>What is &#39;Redundant&#39; Data?</title>
      <link href="/posts/38dbfa3f/"/>
      <url>/posts/38dbfa3f/</url>
      
        <content type="html"><![CDATA[<h1 id="What-is-‘Redundant’-Data"><a href="#What-is-‘Redundant’-Data" class="headerlink" title="What is ‘Redundant’ Data?"></a>What is ‘Redundant’ Data?</h1><h2 id="Redundant-Data"><a href="#Redundant-Data" class="headerlink" title="Redundant Data"></a>Redundant Data</h2><p>When it comes to Data Storage, the word ‘redundant’ or ‘ redundancy’ keeps popping up. So what is data redundancy? </p><p>Data redundancy / Redundant data occurs when <strong>the same piece of data exists in multiple places</strong>.</p><p>Human Word Version(Life examples):</p><p>For example: If every shopping record attaches an individual customer data, even they are actually the Same Customer, therefore this will cause Data Redundancy.</p><p>Another simple example is : you store your notes on your computer with Microsoft Word, and the author will always be yourself, but the Word will record you as Author every time in every doc file. So the Author Name in this case would be the redundant data.</p><hr><h2 id="数据冗余"><a href="#数据冗余" class="headerlink" title="数据冗余"></a>数据冗余</h2><p>数据冗余发生在数据库系统中，指的是一个字段在多个表里重复出现。举个例子，如果每条客户购买商品的信息里都连带记录了客户自身的信息，这样的数据冗余可能造成不一致，因为客户自身的信息可能不一样。数据冗余会导致数据异常和损坏，一般来说设计上应该被避免。数据库规范化防止了冗余而且不浪费存储容量。</p><p>适当的使用外键可以使得数据冗余和异常降到最低。但是，如果考虑效率和便利，有时候也会设计冗余数据，而不考虑数据被破坏的风险。</p>]]></content>
      
      
      <categories>
          
          <category> Azure </category>
          
          <category> Data Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redundant </tag>
            
            <tag> Redundancy </tag>
            
            <tag> Data Storage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>What is Container &amp; Docker?</title>
      <link href="/posts/c9b9b3e2/"/>
      <url>/posts/c9b9b3e2/</url>
      
        <content type="html"><![CDATA[<h1 id="What-is-Container-amp-Docker"><a href="#What-is-Container-amp-Docker" class="headerlink" title="What is Container &amp; Docker?"></a>What is Container &amp; Docker?</h1><h2 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h2><h3 id="What-is-Container"><a href="#What-is-Container" class="headerlink" title="What is Container?"></a>What is Container?</h3><p>A container is <strong><u>a standard unit of software</u> that packages up code and all its dependencies</strong> so the application runs quickly and reliably from one computing environment to another.</p><p><strong>Human language Version</strong>😂:</p><p>Imagine the term ‘Container’ is an actual container in life:</p><p><img "" class="lazyload placeholder" data-original="https://cdn.pixabay.com/photo/2016/11/21/13/20/port-1845350_1280.jpg" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><p>In the old days, if you want to build an app, you have to start from deploying a system such as VM, and different VM(such as Windows &amp; Linux) makes it harder to transfer the app from one system to another.</p><p>Therefore, containers are a solution to the problem of <strong>how to get software to run reliably when <u>moved from one computing environment to another</u>.</strong> </p><p><u><strong>A container consists of an entire runtime environment except they don’t include the operating system: an application, plus all its dependencies, libraries and other binaries, and configuration files needed to run it, bundled into one package.</strong></u> By containerizing the application platform and its dependencies, differences in OS distributions and underlying infrastructure are abstracted away.</p><p><code>In this case:  Different systems are like different quays. And Containers is like actual containers. If you wanna move the containers from Shanghai Quay(Windows) to London Quay(Linux), the containers will not be affected and easy to transfer.</code></p><h4 id="Benefits-of-Container"><a href="#Benefits-of-Container" class="headerlink" title="Benefits of Container:"></a>Benefits of Container:</h4><p>A container may be only tens of megabytes in size, whereas a virtual machine with its own entire operating system may be several gigabytes in size. Because of this, a single server can host far more containers than virtual machines.</p><p>Another major benefit is that virtual machines may take several minutes to boot up their operating systems and begin running the applications they host, while containerized applications can be started almost instantly. That means containers can be instantiated in a “just in time” fashion when they are needed and can disappear when they are no longer required, freeing up resources on their hosts.</p><p>A third benefit is that containerization allows for greater modularity. Rather than run an entire complex application inside a single container, the application can be split in to modules (such as the database, the application front end, and so on). This is the so-called microservices approach.  Applications built in this way are easier to manage because each module is relatively simple, and changes can be made to modules without having to rebuild the entire application. Because containers are so lightweight, individual modules (or microservices) can be instantiated only when they are needed and are available almost immediately.</p><hr><h3 id="什么是容器（Container）"><a href="#什么是容器（Container）" class="headerlink" title="什么是容器（Container）?"></a>什么是容器（Container）?</h3><p>早期，大家都认为硬件抽象层基于hypervisor的虚拟化方式可以最大程度上提供虚拟化管理的灵活性。各种不同操作系统的虚拟机都能通过hypervisor（KVM、XEN等）来衍生、运行、销毁。然而，随着时间推移，用户发现hypervisor这种方式麻烦越来越多。为什么？因为对于hypervisor环境来说，<strong>每个虚拟机都需要运行一个完整的操作系统以及其中安装好的大量应用程序</strong>。但实际生产开发环境里，我们更关注的是自己部署的应用程序，如果每次部署发布我都得搞一个完整操作系统和附带的依赖环境，那么这让任务和性能变得很重和很低下。</p><p>基于上述情况，人们就在想，有没有其他什么方式能让人更加的关注应用程序本身，底层多余的操作系统和环境我可以共享和复用？<strong>换句话来说，那就是<u>我部署一个服务运行好后，我再想移植到另外一个地方，我可以不用再安装一套操作系统和依赖环境</u>。</strong>这就像集装箱运载一样，我把货物一辆兰博基尼跑车（好比开发好的应用APP），打包放到一容器集装箱里，它通过货轮可以轻而易举的从上海码头（CentOS7.2环境）运送到纽约码头（Ubuntu14.04环境）。而且运输期间，我的兰博基尼（APP）没有受到任何的损坏（文件没有丢失），在另外一个码头卸货后，依然可以完美风骚的赛跑（启动正常）。</p><p>Linux Container容器技术的诞生（2008年）就解决了IT世界里“集装箱运输”的问题。Linux Container（简称LXC）它是一种内核轻量级的操作系统层虚拟化技术。Linux Container主要由Namespace和Cgroup两大机制来保证实现。那么Namespace和Cgroup是什么呢？刚才我们上面提到了集装箱，集装箱的作用当然是可以对货物进行打包隔离了，不让A公司的货跟B公司的货混在一起，不然卸货就分不清楚了。那么Namespace也是一样的作用，做隔离。光有隔离还没用，我们还需要对货物进行资源的管理。同样的，航运码头也有这样的管理机制：货物用什么样规格大小的集装箱，货物用多少个集装箱，货物哪些优先运走，遇到极端天气怎么暂停运输服务怎么改航道等等… 通用的，与此对应的Cgroup就负责资源管理控制作用，比如进程组使用CPU/MEM的限制，进程组的优先级控制，进程组的挂起和恢复等等。</p><p>Linux Container容器技术的诞生（2008年）就解决了IT世界里“集装箱运输”的问题。Linux Container（简称LXC）它是一种内核轻量级的操作系统层虚拟化技术。Linux Container主要由Namespace和Cgroup两大机制来保证实现。那么Namespace和Cgroup是什么呢？刚才我们上面提到了集装箱，集装箱的作用当然是可以对货物进行打包隔离了，不让A公司的货跟B公司的货混在一起，不然卸货就分不清楚了。那么Namespace也是一样的作用，做隔离。光有隔离还没用，我们还需要对货物进行资源的管理。同样的，航运码头也有这样的管理机制：货物用什么样规格大小的集装箱，货物用多少个集装箱，货物哪些优先运走，遇到极端天气怎么暂停运输服务怎么改航道等等… 通用的，与此对应的Cgroup就负责资源管理控制作用，比如进程组使用CPU/MEM的限制，进程组的优先级控制，进程组的挂起和恢复等等。</p><hr><h4 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h4><p>容器的特点其实我们拿跟它跟硬件抽象层虚拟化hypervisor技术对比就清楚了，我们之前也提到过，传统的虚拟化（虚拟机）技术，创建环境和部署应用都很麻烦，而且应用的移植性也很繁琐，比如你要把vmware里的虚拟机迁移到KVM里就很繁琐（需要做镜像格式的转换）。那么有了容器技术就简单了，总结下容器技术主要有三个特点：</p><pre><code>1. 极其轻量：只打包了必要的Bin/Lib；2. 秒级部署：根据镜像的不同，容器的部署大概在毫秒与秒之间（比虚拟机强很多）；3. 易于移植：一次构建，随处部署；4. 弹性伸缩：Kubernetes、Swam、Mesos这类开源、方便、好使的容器管理平台有着非常强大的弹性管理能力。</code></pre><h2 id="What-is-Docker"><a href="#What-is-Docker" class="headerlink" title="What is Docker?"></a>What is Docker?</h2><h3 id="What-is-Docker-1"><a href="#What-is-Docker-1" class="headerlink" title="What is Docker?"></a>What is Docker?</h3><p>Docker is <u><strong>not</strong> equal</u> to Container. It’s just <u>one of the platforms</u> that can deliver containers.</p><p><strong>Docker is a set of platform as a service products that use OS-level virtualization to deliver software in packages called containers.</strong> </p><hr><h3 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker?"></a>什么是Docker?</h3><p>当前，docker几乎是容器的代名词，很多人以为docker就是容器。其实，这是错误的认识，除了docker  还有coreos。所以，容器世界里并不是只有docker一家。既然不是一家就很容易出现分歧。任何技术出现都需要一个标准来规范它，不然各搞各的很容易导致技术实现的碎片化，出现大量的冲突和冗余。因此，在2015年，由Google，Docker、CoreOS、IBM、微软、红帽等厂商联合发起的OCI（Open Container  Initiative）组织成立了，并于2016年4月推出了第一个开放容器标准。标准主要包括runtime运行时标准和image镜像标准。标准的推出，有助于替成长中市场带来稳定性，让企业能放心采用容器技术，用户在打包、部署应用程序后，可以自由选择不同的容器Runtime；同时，镜像打包、建立、认证、部署、命名也都能按照统一的规范来做。</p><p>两种标准主要包含以下内容：</p><p><code>1.容器运行时标准 （runtime spec）</code></p><p>a). creating：使用 create 命令创建容器，这个过程称为创建中 b). created：容器创建出来，但是还没有运行，表示镜像和配置没有错误，容器能够运行在当前平台 c). running：容器的运行状态，里面的进程处于 up 状态，正在执行用户设定的任务 d). stopped：容器运行完成，或者运行出错，或者 stop 命令之后，容器处于暂停状态。这个状态，容器还有很多信息保存在平台中，并没有完全被删除</p><p><code>2.容器镜像标准（image spec）</code></p><p>a). 文件系统：以 layer 保存的文件系统，每个 layer 保存了和上层之间变化的部分，layer 应该保存哪些文件，怎么表示增加、修改和删除的文件等; b). config 文件：保存了文件系统的层级信息（每个层级的 hash 值，以及历史信息），以及容器运行时需要的一些信息（比如环境变量、工作目录、命令参数、mount 列表），指定了镜像在某个特定平台和系统的配置。比较接近我们使用 docker inspect <image_id> 看到的内容; c). manifest 文件：镜像的 config 文件索引，有哪些 layer，额外的 annotation 信息，manifest 文件中保存了很多和当前平台有关的信息; d). index 文件：可选的文件，指向不同平台的 manifest 文件，这个文件能保证一个镜像可以跨平台使用，每个平台拥有不同的 manifest 文件，使用 index 作为索引。</p><h2 id="Related-Quiz"><a href="#Related-Quiz" class="headerlink" title="Related Quiz:"></a>Related Quiz:</h2><p>Q: Which service simplifies the process of configuring, deploying, and  managing a simple containerized application on the Azure cloud?</p><ol><li><p>Azure Container Instances</p></li><li><p>Azure Functions</p></li><li><p>Azure App Service</p></li><li><p>Azure Pipelines</p></li></ol><p>A: Azure Container Instances</p><p>Containers are somewhat like virtual machines except they don’t include the operating system. This makes it easy to deploy them because they’re very lightweight compared to virtual machines. In fact, containers run on virtual machines.</p><p>Microsoft provides a variety of ways to run containers. The simplest way is to use Azure Container Instances. This service lets you run a container using a single command.</p><hr><p>Q: What Azure Cloud compute service is useful when planning a ‘lift-and-shift” migration of an application from an on-premises environment to the Azure Cloud?</p><ol><li><p>Azure Virtual Machines</p></li><li><p>Azure Functions</p></li><li><p>Azure Container Instances</p></li><li><p>Azure DevOps</p></li></ol><p>A: Azure Container Instances</p><p>If you currently have an application running on a Windows or Linux server, then the most straightforward way to migrate it to Azure is to do what’s called a “lift and shift” migration. That is, you simply lift the application from your on-premises server and shift it to a virtual server in the cloud. Azure VMs are known as Infrastructure-as-a-Service because they’re traditional IT infrastructure components that are offered as a service.</p><h2 id="References-amp-Credit："><a href="#References-amp-Credit：" class="headerlink" title="References &amp; Credit："></a>References &amp; Credit：</h2><p><a href="https://www.cnblogs.com/qcloud1001/p/9273549.html">https://www.cnblogs.com/qcloud1001/p/9273549.html</a></p><p><a href="https://www.cio.com/article/2924995/what-are-containers-and-why-do-you-need-them.html">https://www.cio.com/article/2924995/what-are-containers-and-why-do-you-need-them.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Azure </category>
          
          <category> Data Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Container </tag>
            
            <tag> Docker </tag>
            
            <tag> Azure </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
