<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git_Branch</title>
      <link href="/posts/3cc0dd7/"/>
      <url>/posts/3cc0dd7/</url>
      
        <content type="html"><![CDATA[<h1 id="Git-Branch"><a href="#Git-Branch" class="headerlink" title="Git_Branch"></a>Git_Branch</h1><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/branch.jpg" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><blockquote><p>Branch 分支</p></blockquote><p>正常情况下，如果想要一个脱离主线的分支来开发项目，常常需要完全创建一个源代码目录的副本，对大项目来说，这样的过程会耗费很多时间，所以这是一个比较低效的做法。但是<strong>git分支则不同，你会发现使用分支和合并分支是非常方便的</strong>。</p><p>首先要知道<u><strong>git保存数据不是保存的文件的差异或变化</strong></u> ，而是一系列<u><strong>不同时刻</strong></u>( <u><strong>timelines</strong></u> )的<u><strong>文件快照</strong></u>（ <u><strong>snapshots</strong></u> ) 。<br>在进行提交操作时，Git会保存一个提交对象(blob对象)，该提交对象会包含一个指向暂存内容快照的指针，还包含作者的姓名,邮箱和提交时输入的信息以及指向它父对象的指针，首次提交时提交对象没有父对象，普通提交产生的提交对象有一个父对象，而由多个分支合并产生的提交对象 会有多个父对象。</p><p>这里举一个例子，假设现在工作目录中有三个将要被暂存和提交的文件，当使用git commit进行提交操作时，git会先计算每个子目录的校验和，然后在git仓库中为这些校验和保存为树对象，随后Git便会创建一个提交对象，它除了上面提到的那些信息外，还包含指向这个树对象的指针。现在仓库中有五个对象：三个blob对象（保存着文件快照）一个树对象（记录着目录结构和blob对象 索引）以及一个提交对象（包含着指向前述树对象的指针和所有提交信息）</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Branch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git_Basics</title>
      <link href="/posts/51b6a0f8/"/>
      <url>/posts/51b6a0f8/</url>
      
        <content type="html"><![CDATA[<h1 id="Git-Basics"><a href="#Git-Basics" class="headerlink" title="Git_Basics"></a>Git_Basics</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>Git is used for tracking changes in source code during software development.<br><strong>It is designed for coordinating work amongst programmers, but <u>it can be used to track changes in any set of files</u>.</strong></p><h2 id="Basic-Workflow"><a href="#Basic-Workflow" class="headerlink" title="Basic Workflow"></a>Basic Workflow</h2><p>The basic workflow for using Git includes <strong>staging, committing and pushing changes</strong>.<br>Before a change can be committed it must be staged and to apply your changes for everyone else on the team, the changes must be pushed to the remote repository.</p><hr><h2 id="Common-Commands-and-Concepts"><a href="#Common-Commands-and-Concepts" class="headerlink" title="Common Commands and Concepts"></a><strong>Common Commands and Concepts</strong></h2><h3 id="Get-help-git-help-everyday"><a href="#Get-help-git-help-everyday" class="headerlink" title="Get help ( git help everyday )"></a><strong>Get help ( <u>git help everyday</u> )</strong></h3><p>This open a html on your default browser and you can check the manual of git.</p><h3 id="Cloning-a-Repository-git-clone"><a href="#Cloning-a-Repository-git-clone" class="headerlink" title="Cloning a Repository (git clone)"></a><strong>Cloning a Repository (<em>git clone</em>)</strong></h3><p>To download a remote repository you can use the git clone command and provide the URL of the remote repository. Example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># git clone [REPOSITORY_URL]</span><br><span class="line">git clone https://github.com/bob-crutchley/vim</span><br></pre></td></tr></table></figure><h3 id="Create-an-empty-Git-repository-or-reinitialize-an-existing-one-git-init"><a href="#Create-an-empty-Git-repository-or-reinitialize-an-existing-one-git-init" class="headerlink" title="Create an empty Git repository or reinitialize an existing one(git init)"></a><strong>Create an empty Git repository or reinitialize an existing one(git init)</strong></h3><h3 id="Staging-a-Change-git-add"><a href="#Staging-a-Change-git-add" class="headerlink" title="Staging a Change (git add)"></a><strong>Staging a Change (<em>git add</em>)</strong></h3><p><strong>Staging is the step that you must take before committing a change.</strong><br>Staging is a feature in Git that enables the developer to choose what changes are actually going to get committed to the repository when the commit is made. There is a few ways you stage files:</p><h3 id="Committing-a-Change-git-commit"><a href="#Committing-a-Change-git-commit" class="headerlink" title="Committing a Change (git commit)"></a><strong>Committing a Change (<em>git commit</em>)</strong></h3><p>When you make a commit to a Git repository, you are effectively “saving” the changes that you have staged to the repository.</p><p>Unlike saving files in most other programs, Git also requires <strong>a message</strong> to be saved against the commit along with some basic information about the user from the Git config shown above.</p><p>What you put in this message is important, <strong>so that you understand what it is that you changed on that particular commit</strong>.</p><blockquote><p>‘message’ here is like a ‘flag’ or ‘tag’, it is not the change you made in git add, it is just a reminder/sticker of what you have done.</p><p>commit的message是为了提醒你在git add里做的改动的总结/提醒/便签，并非是你要进行改动的内容</p></blockquote><p><strong>Commits can be reverted</strong>, so it helps when there is a concise message about what was implemented or removed.</p><h4 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting:"></a><strong>Troubleshooting:</strong></h4><p>If getting ^X mode (^]^D^E^F^I^K^L^N^O^Ps^U^V^Y) at bottom of screen(whether it’s on Mac or Windows), it’s because the default text editor is <strong>vim</strong>. If you wish to use <strong>Nano</strong> you should type the following command:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.editor &quot;nano&quot;</span><br></pre></td></tr></table></figure><h3 id="Checking-your-commit-git-log"><a href="#Checking-your-commit-git-log" class="headerlink" title="Checking your commit(git log)"></a><strong>Checking your commit(<em>git log</em>)</strong></h3><h3 id="Local-Repository-Status-git-status"><a href="#Local-Repository-Status-git-status" class="headerlink" title="Local Repository Status (git status)"></a><strong>Local Repository Status (git status)</strong></h3><p>Knowing the current state of your local repository is very useful so that you can understand what commands to run.<br>For instance, <strong>how can you know what files have been staged and not staged</strong>?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><hr><h2 id="Abbreviations-Acronym"><a href="#Abbreviations-Acronym" class="headerlink" title="Abbreviations_Acronym"></a>Abbreviations_Acronym</h2><p>It’s not necessary to memorize these, but it helps you understand the command better.</p><blockquote><p>cd: change directory</p><p>pwd: print work directory</p><p>ls: list</p><p>mkdir: make directory</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git_Introduction_to_Source_Control</title>
      <link href="/posts/518e617c/"/>
      <url>/posts/518e617c/</url>
      
        <content type="html"><![CDATA[<h1 id="Git-Introduction-to-Source-Control"><a href="#Git-Introduction-to-Source-Control" class="headerlink" title="Git_Introduction_to_Source_Control"></a>Git_Introduction_to_Source_Control</h1><blockquote><p>Git explained in short words:</p><p><strong><u>distributed</u></strong> <u><strong>source control</strong></u> system</p><p><strong>分布式</strong> <strong>版本控制</strong> 系统</p></blockquote><h2 id="Distributed-vs-Centralized-分布式-vs-集中式"><a href="#Distributed-vs-Centralized-分布式-vs-集中式" class="headerlink" title="Distributed vs Centralized 分布式 vs 集中式"></a>Distributed vs Centralized 分布式 vs 集中式</h2><p><strong>Distributed:</strong></p><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/distributed.jpg" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><hr><p><strong>Centralized:</strong></p><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/centralized.jpg" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><h2 id="Source-Control-版本控制"><a href="#Source-Control-版本控制" class="headerlink" title="Source Control 版本控制"></a>Source Control 版本控制</h2><p>Source control is vital for managing software development projects. Being able to track changes to code allows developers to:</p><ul><li>centralise all code changes and additions to one code repository</li><li>allow for simple and effective collaboration within development teams</li><li>control the integration of new code into the codebase</li><li>track changes from the entire team over the full lifetime of the project</li><li>revert code back to previous versions</li></ul><h2 id="Source-Control-Management-SCM-版本控制管理"><a href="#Source-Control-Management-SCM-版本控制管理" class="headerlink" title="Source Control Management (SCM) 版本控制管理"></a><u>Source Control Management (SCM)</u> 版本控制管理</h2><p>We use <strong><u>source control management (SCM) systems</u></strong> to implement source control practices. These provide the ability to:</p><ul><li>Store code in a central repository</li><li>Track changes over time</li><li>Create code branches so that additions are made in isolation from stable code</li><li>Merge new code into a <strong>stable release branch</strong>, known as the <strong>main branch</strong></li><li>Integrate with CI/CD automation tools (such as Jenkins and CircleCI) such that code will be built and tested as it is generated and pushed  to the repository</li></ul><hr><h3 id="Repositories-Short-for-Repo-仓库"><a href="#Repositories-Short-for-Repo-仓库" class="headerlink" title="Repositories (Short for Repo) 仓库"></a><strong>Repositories</strong> (Short for <strong><u>Repo</u></strong>) <strong>仓库</strong></h3><p>To keep code content in one place, SCM systems <strong>store code in a repository</strong>. This essentially functions as a big bucket for all your code to live in.</p><blockquote><p>repository /rɪˈpɒzətri/ 仓库; 贮藏室</p></blockquote><h3 id="Branching"><a href="#Branching" class="headerlink" title="Branching"></a>Branching</h3><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/barnch,png.png" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><p>Branching allows for each developer to work on new features in isolation by creating a version of the source code that only they are working on.</p><p>This new version is called a feature branch, while the source code lives on the main branch.</p><p>Once changes have been made and the feature implemented, the feature branch code is merged back into the source code on the main branch.</p><p>The SCM system will automatically detect the differences between the feature and main branches and alert the developer if there are any conflicts. </p><h3 id="Code-Tracking"><a href="#Code-Tracking" class="headerlink" title="Code Tracking"></a>Code Tracking</h3><p>Code tracking allows development teams to keep track of all changes made to a project over time. This allows for greater organisation as all additions to code are fully documented and attributed to the developer who made them.</p><p>If a feature causes a bug in the software after it is merged to main, code tracking makes it easy to revert the main branch to a previous stable state until fixes can be made.</p><hr><h3 id="SCM-Tools"><a href="#SCM-Tools" class="headerlink" title="SCM Tools"></a>SCM Tools</h3><p>Some common SCM tools are:</p><ul><li><strong>Git</strong></li><li>Mercurial</li><li>Subversion (often abbreviated to SVN)</li><li>CVS</li><li>Perforce</li></ul><p>Git is by far the most common SCM system used in software development. Git is a free and open source version control system.</p><p>Its ubiquity is largely due to how easy it is to learn and its tiny footprint, which is a result of being written in low-level C code.</p><p>It is a decentralised SCM tool, meaning its operations are largely performed on your local computer and requires no communication with an external server, resulting in very fast performance.</p><hr><h3 id="Repository-Hosting-Services"><a href="#Repository-Hosting-Services" class="headerlink" title="Repository Hosting Services"></a><strong>Repository Hosting Services</strong></h3><p>There are several web-based version control <strong>repository hosting services</strong> out there:</p><ul><li><a href="https://github.com/">GitHub</a></li><li><a href="https://about.gitlab.com/">GitLab</a></li><li><a href="https://gitee.com/">Gitee</a></li><li>Bitbucket</li><li>SourceForge</li><li>Launchpad</li></ul><p>Many cloud providers have their own code repository offerings which offer simple and powerful integration with other cloud services:</p><ul><li>AWS CodeCommit</li><li><strong>Azure Repos (as part of Azure DevOps)</strong></li><li>Google Cloud Source Repositories</li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Repo </tag>
            
            <tag> Repositories </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DevOps_Part1</title>
      <link href="/posts/98993eff/"/>
      <url>/posts/98993eff/</url>
      
        <content type="html"><![CDATA[<h1 id="DevOps-Part-1"><a href="#DevOps-Part-1" class="headerlink" title="DevOps_Part 1"></a>DevOps_Part 1</h1><h2 id="How-Things-Used-to-be-Done"><a href="#How-Things-Used-to-be-Done" class="headerlink" title="How Things Used to be Done"></a>How Things Used to be Done</h2><p>Traditionally, software companies are structured as separate, stratified teams for <strong>development, quality assurance (sometimes known as testers), security, and operations</strong>.</p><p>These teams tend to have varying and sometimes conflicting goals and there is often poor communication between them, regularly resulting in work that is out of sync with other parts of the organisation. These isolated teams are referred to as <strong>silos</strong>.</p><blockquote><p>silo /ˈsaɪləʊ/  (农场储存草料、谷物等的)筒仓</p></blockquote><p> <img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/devopsvssiolos.png" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><hr><h2 id="How-DevOps-Changes-Things-Up"><a href="#How-DevOps-Changes-Things-Up" class="headerlink" title="How DevOps Changes Things Up"></a>How DevOps Changes Things Up</h2><p>There are two key elements to the DevOps approach that ensure that the methodology works: <strong>automation</strong> and <strong>measurement</strong>.</p><h3 id="Automation"><a href="#Automation" class="headerlink" title="Automation"></a><strong>Automation</strong></h3><p>A DevOps culture encourages automation in as many areas of the production pipeline as possible. <strong><u>As a rule of thumb: if a machine could do it, a machine should be doing it.</u></strong></p><h4 id="Continuous-Integration-CI-amp-Continuous-Deployment-Delivery-CD-持续集成-CI-amp-持续部署-CD"><a href="#Continuous-Integration-CI-amp-Continuous-Deployment-Delivery-CD-持续集成-CI-amp-持续部署-CD" class="headerlink" title="Continuous Integration (CI) &amp; Continuous Deployment/Delivery (CD) - 持续集成(CI) &amp; 持续部署(CD)"></a><strong>Continuous Integration (CI)</strong> &amp; Continuous Deployment/Delivery (CD) - 持续集成(CI) &amp; 持续部署(CD)</h4><h5 id="Continuous-Integration-CI-持续集成-CI"><a href="#Continuous-Integration-CI-持续集成-CI" class="headerlink" title="Continuous Integration (CI) - 持续集成(CI)"></a><strong>Continuous Integration (CI)</strong> - 持续集成(CI)</h5><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/continuousinte.png" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><ul><li>When code is committed to a repository, it is automatically built and subjected to acceptance tests.</li><li>Test failures result in the code being prevented from integrating  with the repository. Developers are immediately notified of a test  failure so they can fix issues as quickly as possible.</li></ul><hr><p><strong>Continuous Integration持续集成（CI），<u>是指在一段时间内（如：约定好的一天内或是一个上午），多次的将代码提交到主干上去</u>。自然，<u>每次都要通过测试</u>。</strong></p><p>大师Martin Fowler对持续集成是这样定义的:持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通常每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试)来验证，从而尽快地发现集成错误。许多团队发现这个过程可以大大减少集成的问题，让团队能够更快的开发内聚的软件。</p><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/ci2.png" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><p>为什么要使用持续集成？</p><ul><li>减少风险<br> 可以快速的发现错误</li><li>可快速定位错误</li><li>可降低代码整合的错误</li><li>防止长时间过后，集成失败</li><li>可以更好的了解进度，更好的收集数据</li></ul><p><strong>持续集成并不解决BUG，而是能够更加快速的发现以及更正。</strong></p><p><strong>自然地，当我们持续集成的时候，必须也要保证代码的可行性，简单讲就是单元测试通过了，我们才去集成</strong>。</p><h5 id="Continuous-Deployment-Delivery-CD-持续部署-交付-CD"><a href="#Continuous-Deployment-Delivery-CD-持续部署-交付-CD" class="headerlink" title="Continuous Deployment/Delivery (CD) - 持续部署/交付(CD)"></a>Continuous Deployment/Delivery (CD) - 持续部署/交付(CD)</h5><ul><li>As new code passes acceptance tests, it is automatically integrated into a deployment environment.</li><li>Being able to choose a version to deploy with one push a button requires a fair amount of automation.</li></ul><hr><p><strong>持续交付（Continuous delivery）CD 指的是，<u>频繁地将软件的新版本，交付给质量团队或者用户</u>。持续交付强调的是，<u>无论如何更新，都可以随时随地的交付软件的</u>。</strong></p><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/chixujiaofu1.png" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><p>持续部署（Continuous deployment）是持续交付的下一步，指的是代码通过评审以后，<u><strong>自动</strong>部署到生产环境</u> :</p><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/chixubushu.png" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><hr><p>Difference:</p><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/differencechi.png" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><hr><h3 id="Measurement"><a href="#Measurement" class="headerlink" title="Measurement"></a><strong>Measurement</strong></h3><p>Measurement is central to ensuring that a production pipeline is working efficiently.</p><p>The types of metrics we work to measure include：</p><h4 id="Frequency-of-deployments"><a href="#Frequency-of-deployments" class="headerlink" title="Frequency of deployments"></a>Frequency of deployments</h4><p>DevOps pipelines encourage frequent, smaller updates to software.</p><h4 id="Mean-time-to-Recovery-MTTR）"><a href="#Mean-time-to-Recovery-MTTR）" class="headerlink" title="Mean time to Recovery (MTTR）"></a>Mean time to Recovery (MTTR）</h4><p>This refers to <strong>the average time</strong> it takes to <strong><u>Solve problems</u></strong> that impact the end-user.</p><p>This is a more worthwhile metric than charting the frequency of failures as DevOps is less interested in minimising problems than the speed at which they are solved. </p><h4 id="Mean-time-to-Discovery-MTTD"><a href="#Mean-time-to-Discovery-MTTD" class="headerlink" title="Mean time to Discovery (MTTD)"></a>Mean time to Discovery (MTTD)</h4><p>This refers to <strong>how quickly</strong> problems are <strong><u>Discovered</u></strong>.</p><p>This metric is measured from the point of integration into production to the point the problem is identified. Naturally, faster MTTDs are more desirable.</p><h4 id="System-availability"><a href="#System-availability" class="headerlink" title="System availability"></a>System availability</h4><h4 id="Service-performance"><a href="#Service-performance" class="headerlink" title="Service performance"></a>Service performance</h4><hr><h2 id="Additional-Reading"><a href="#Additional-Reading" class="headerlink" title="Additional Reading"></a>Additional Reading</h2><p>Mandarin: <a href="https://www.cnblogs.com/xiugeng/p/10555847.html">https://www.cnblogs.com/xiugeng/p/10555847.html</a></p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scrum</title>
      <link href="/posts/67fd1987/"/>
      <url>/posts/67fd1987/</url>
      
        <content type="html"><![CDATA[<h1 id="Scrum"><a href="#Scrum" class="headerlink" title="Scrum"></a>Scrum</h1><h2 id="Scrum-1"><a href="#Scrum-1" class="headerlink" title="Scrum"></a>Scrum</h2><p>The scrum framework is <strong>iteritive</strong> and will produce a potentially <strong>shippable</strong> increment at the end of every sprint. A potentially shippable increment means that it will add functionality on what was there previously, therefore adding value. The additional code should be “shippable” (it shouldn’t be half broken, it should be ready to distribute).</p><hr><h2 id="What-is-a-Sprint"><a href="#What-is-a-Sprint" class="headerlink" title="What is a Sprint?"></a>What is a Sprint?</h2><p>A sprint is <strong>a time-boxed event</strong> in which everything happens.<br>This could be anywhere between one week and four weeks. </p><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/sprint.jpeg" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><h3 id="Product-Backlog-产品列表"><a href="#Product-Backlog-产品列表" class="headerlink" title="Product Backlog  / 产品列表"></a><strong><u>Product</u> Backlog</strong>  / 产品列表</h3><p>The Product Backlog is an ordered list of all features, enhancements and fixes to be made to the product in future releases.</p><blockquote><p><strong>产品列表  / Product Backlog：根据用户价值进行优先级排序的高层需求</strong></p></blockquote><p><strong><u>The Product Owner</u></strong> is <strong>responsible</strong> for the <strong>Product Backlog</strong>, including its content, availability, and ordering.</p><blockquote><p><strong>产品负责人 / Product Owner： 负责维护产品订单的人，代表利益相关者的利益。</strong></p><p><strong>Scrum主管 / Scrum Master： 为Scrum过程负责的人，确保scrum的正确使用并使得Scrum的收益最大化。</strong></p></blockquote><p>The development team will collaborate with the Product Owner in adding details where necessary.</p><p>Product Backlog items have the attributes of a description, order, estimate, and value.</p><p>Product Backlog items often include test descriptions that will prove its completeness when “Done”.</p><h3 id="Sprint-Backlog-冲刺订单"><a href="#Sprint-Backlog-冲刺订单" class="headerlink" title="Sprint Backlog / 冲刺订单"></a><strong><u>Sprint</u> Backlog</strong> / 冲刺订单</h3><p>The Sprint Backlog is the set of Product Backlog items selected for the Sprint.</p><blockquote><p><strong>冲刺订单 Sprint Backlog：要在冲刺中完成的任务的清单</strong></p></blockquote><p>The Sprint Backlog makes visible all the work that the Development Team identifies as necessary to meet the Sprint Goal.</p><p>As work is worked on it moves through the workflow. The workflow usually has a minimum of three stages, “To be completed”, “In progress” and “Done”.</p><hr><h2 id="Scrum-Roles"><a href="#Scrum-Roles" class="headerlink" title="Scrum Roles"></a>Scrum Roles</h2><p><strong>Project Manager (PM)</strong></p><p>PM’s manage projects and will overview expenses. They will also try to reduce risk on the project</p><p><strong>Product Owner (PO)</strong></p><p>PO’s are the sole person responsible for managing the Product Backlog (i.e. the list of features to be worked on).</p><p><strong>Business Analyst (BA)</strong></p><p>Support the product owner by gathering requirements, provide guidance on what to build. They usually work across many products.</p><p><strong>Development Team</strong></p><p>A multi-disciplinary team usually comprised of software architects, designers, programmers and testers.</p><p><strong>Scrum Master (SM)</strong></p><p>Facilitates Scrum. The scrum master helps those outside the scrum team understand which interactions are beneficial. The scrum masters services the development team by removing impediments, facilitates meetings and coaches in self-organisation</p><hr><h3 id="Additional-Reading-Differences-between-Scrum-Master-and-Project-Manager"><a href="#Additional-Reading-Differences-between-Scrum-Master-and-Project-Manager" class="headerlink" title="Additional Reading - Differences between Scrum Master and Project Manager"></a>Additional Reading - Differences between Scrum Master and Project Manager</h3><p><strong>Scrum Master vs Project Manager</strong></p><p>English: <a href="https://medium.com/the-value-maximizers/scrum-master-vs-project-manager-an-overview-of-the-differences-73104d0264ab">https://medium.com/the-value-maximizers/scrum-master-vs-project-manager-an-overview-of-the-differences-73104d0264ab</a></p><p>Mandarin: <a href="https://www.jianshu.com/p/50687f8d5a6e">https://www.jianshu.com/p/50687f8d5a6e</a></p><hr><h2 id="Scrum-Meetings"><a href="#Scrum-Meetings" class="headerlink" title="Scrum Meetings"></a>Scrum Meetings</h2><p>There are four different key meetings which take place in the sprint and are discussed in this module.</p><p>These meetings are:</p><pre><code>Sprint Planning MeetingDaily StandupSprint Review MeetingSprint Retrospective Meeting</code></pre><blockquote><p>计划会 / Sprint Planning Meeting：在每个冲刺之初，由产品负责人讲解需求，并由开发团队进行估算的计划会议。</p><p>每日立会 / Daily Standup Meeting：团队每天进行沟通的内部短会，因一般只有15分钟且站立进行而得名。</p><p>评审会 / Review Meeting：在冲刺结束前给产品负责人演示并接受评价的会议。</p><p>反思会/回顾会 / Retrospective Meeting：在冲刺结束后召开的关于自我持续改进的会议。</p></blockquote><hr><h2 id="Product-Backlog-Items-PBI"><a href="#Product-Backlog-Items-PBI" class="headerlink" title="Product Backlog Items (PBI)"></a>Product Backlog Items (PBI)</h2><p>产品待办项/产品任务列表（Product Backlog Item/<strong>PBI</strong>）是可以预知的所有任务，包括功能性的和非功能性的任务，PBI属于计划阶段，指出了我们目标.</p><p>The most common type of Product Backlog Item (PBI) is a <strong>User Story</strong>.<br>They are however multiple forms an item can take and they are:</p><ul><li>User stories</li><li>Use cases</li><li>Bugs, errors and fixes</li><li>Constraints</li></ul><h3 id="User-Story"><a href="#User-Story" class="headerlink" title="User Story"></a>User Story</h3><h4 id="User-Story-1"><a href="#User-Story-1" class="headerlink" title="User Story"></a>User Story</h4><p>A user story is an end goal expressed from the user’s perspective.</p><ul><li>Focuses on <u>what they want to do</u> rather than how to do it</li><li>These users <u>can be external or internal</u></li><li>They should be expressed <u>in simple language that everyone can understand</u></li></ul><hr><h5 id="用户故事-user-story"><a href="#用户故事-user-story" class="headerlink" title="用户故事(user story)"></a>用户故事(user story)</h5><p><strong>一件用户通过系统完成他一个有价值的目标的事。</strong></p><p>什么是用户故事(user story)<br>    假定这个项目的客户是个饮料自动售货机的制造商。他们要求我们为他们的售货机开发一款软件。我们可以找他们的市场经理了解这个软件的需求。<br>    因此，我们的客户就是他们的市场经理。谈需求的时候，有一回他这样说：“用户往售货机每塞一个硬币，售货机都要显示当前该客户已经投了多少钱。当用户投的钱够买某一款饮料时，代表这款饮料的按钮的灯就会亮。如果那个用户按了这个按钮，售货机就放一罐饮料到出口，然后找零钱给他。”<br>    上面的话描述的是一件事情，一件用户通过系统完成他一个有价值的目标（买一罐饮料）的事。这样的过程就叫“用户案例(user case)”或者“用户故事(user story)”。也就是说，上面我们的客户所说的话，就是在描述一个用户故事（user story）。<br>    (我解释一下为什么用故事这个词，没兴趣也可以忽略。在一个系统面前，每个用户要完成同样的目标，都要做这个系统设定的例行的事，这件事情不是一个例子，所以不叫事例，这也不是故事，也不能算一段历程，而是一个例行的事。)<br>    如果我们想要记下这段用户故事，我们可能会用这样的格式：<br>    名称：卖饮料<br>    事件：</p><pre><code>1. 用户投入一些钱。    2. 售货机显示用户已经投了多少钱。    3. 如果投入的钱足够买某种饮料，这种饮料对应的按钮的灯就会亮。    4. 用户按了某个亮了的按钮。    5. 售货机卖出一罐饮料给他。    6. 售货机找零钱给他。    注意到，一个用户故事里面的事件可以这样描述：    1. 用户做XX。    2. 系统做YY。     3. 用户做ZZ。    4. 系统做TT。    5.  ... </code></pre><p><u><strong>用户故事只是描述系统的外在行为</strong></u></p><p>一个用户故事只是以客户能够明白的方式，描述了一个系统的外在行为，它完全忽略了系统的内部动作。比如，下面有下划线的那些文字，就属于不应该出现在用户故事中的系统内部动作：</p><p>  \1. 用户投入一些钱。</p><p>  \2. 售货机将塞进来的钱存在钱箱里，然后发送一条命令给屏幕，屏幕显示目前已经投入的金额。</p><p>  \3. 售货机查询数据库里面所有饮料的价格，判定钱足够买哪些饮料，对于钱足够买的那些饮料，对应的按钮的灯就会亮起来。</p><p>  \4. 用户按下一个亮起来的按钮。</p><p>  \5. 售货机卖出一罐饮料给用户，然后将数据库里面该饮料的存货数量减1。</p><p>  \6. 售货机找零钱给用户。</p><p>  不管是口头描述的，还是书面形式，这样的内容是描述用户故事时一个很常见的错误。特别的，千万不要提及任何有关数据库，记录，字段之类的对客户一点意义都没有的东西。</p><hr><h4 id="Epic-User-Stories-Tasks"><a href="#Epic-User-Stories-Tasks" class="headerlink" title="Epic, User Stories, Tasks"></a>Epic, User Stories, Tasks</h4><p>An <strong>Epic</strong> is made up of multiple user stories.</p><p>A User story is made up of multiple <strong>Task</strong>s.</p><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/userst.png" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/dffd8d011d55eb8a.png" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><hr><h3 id="DOR-DOD"><a href="#DOR-DOD" class="headerlink" title="DOR DOD"></a><strong>DOR DOD</strong></h3><p><strong>Definition of Ready (DoR)</strong></p><p>Definition of Ready (DoR) defines what a product backlog item needs before it can go into the sprint backlog. </p><p>Checklist:</p><ul><li>Technical details have been discussed on the item and agreed</li><li>Assigning a priority</li><li><strong>Timing Estimates</strong></li></ul><p><strong>Definition of Done (DoD)</strong></p><p>Definition of Done (DoD) defines what is needed before it can be regarded as complete. A definition of done can be applied to a feature, a sprint or a release.</p><p>Checklist:</p><ul><li>Unit testing written and passed.</li><li>Documentation updated</li><li>Peer code review completed</li></ul><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/f2449d468bd7ab0a.png" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><hr><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a><strong>Summary</strong></h3><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/definition-of-ready.webp" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><hr><h2 id="Risk-Assessments"><a href="#Risk-Assessments" class="headerlink" title="Risk Assessments"></a>Risk Assessments</h2><h4 id="Control-Measures"><a href="#Control-Measures" class="headerlink" title="Control Measures"></a>Control Measures</h4><p>When planning control measures, one of the following three solutions may be drawn:</p><ol><li><code>Mitigation</code> - decreasing the likelihood of the hazard’s occurrence, or the impact it would have on the project</li><li><code>Acceptance</code> - sometimes it can be too costly to mitigate the risk in comparison to the impact it would have on the project, in  which case we may choose to do nothing</li><li><code>Transfer</code> - assigning the risk to a third party, usually in the form of an insurance policy</li></ol><h4 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h4><p>In general they should have each of the following elements:</p><ul><li><code>Description</code> - what is the scenario?</li><li><code>Evaluation</code> - what would happen if this scenario occurred?</li><li><code>Likelihood</code> - how likely is it to occur?</li><li><code>Impact Level</code> - how devastating to the project would it be if this occurred?</li><li><code>Responsibility</code> - who’s responsibility is it to mitigate this risk?</li><li><code>Response</code> - what would we do if the scenario occurred?</li><li><code>Control Measures</code> - what can we do to decrease the likelihood and/or impact?</li></ul><hr><h2 id="Estimations"><a href="#Estimations" class="headerlink" title="Estimations"></a>Estimations</h2><p>In scrum we use **<u>story point</u>**s as to estimate <strong><u>the amount of</u></strong> work needed to complete a task.</p><p>A story point is a unitless measurement. It is the relative difference which are important.</p><p><strong><u>TIME IS NOT USED</u> TO ESTIMATE WORK</strong>:</p><blockquote><p>Time based estimates don’t work because an hour’s work will vary drastically between developers, so it becomes a bad measurement for predicting amount of work. It is easier for developers to agree on relative amounts of work. </p></blockquote><h3 id="Burndown-Charts"><a href="#Burndown-Charts" class="headerlink" title="Burndown Charts"></a>Burndown Charts</h3><p>By estimating all the tasks done, when they are completed throughout the sprint, <strong>the amount of work left will decrease</strong>. This can be outputted to a graph known as a burndown chart.</p><p><strong>They all for team visibility on progress.</strong></p><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/burndownchart.png" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><hr><h2 id="Prioritisation-using-MoSCoW"><a href="#Prioritisation-using-MoSCoW" class="headerlink" title="Prioritisation using MoSCoW"></a>Prioritisation using MoSCoW</h2><p>The MoSCoW method is a popular prioritisation techinque used for managing requirements.</p><p>It is important to work with stakeholders to determine the importance of each component of the requirements in order to guarantee a <strong>minimum viable product (MVP)</strong> is achieved. </p><p>一般在迭代计划会上使用MoSCoW方法进行这种排序，将要Sprint Backlog中的条目分为四级（其实只有前3级）：<br>Must：必须做的；<br>Shoud：应该做的；<br>Could：可以做的；<br>Would not：不要做的。</p><p>如果使用故事墙Story Wall进行管理，最好也按M、S、C（W其实不会出现）三个级别排放待开发的故事，优先拿M，最后动C。如果愿意，可以用三种颜色的便签纸来表示，防止M、S完成前就有人动C。</p><p>MoSCoW只是对Sprint Backlog的排序方法.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Agile </tag>
            
            <tag> Scrum </tag>
            
            <tag> Software Development </tag>
            
            <tag> Project Management </tag>
            
            <tag> Sprint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Agile</title>
      <link href="/posts/b6d6088d/"/>
      <url>/posts/b6d6088d/</url>
      
        <content type="html"><![CDATA[<h1 id="Agile-敏捷项目管理"><a href="#Agile-敏捷项目管理" class="headerlink" title="Agile  敏捷项目管理"></a>Agile  敏捷项目管理</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>Agile/ˈædʒaɪl/ is the most common <strong>software development</strong> methodology - it is an <strong>iterative</strong>(/‘ɪtərətɪv/<strong>迭代式</strong>) methodology to create software. The simplest and oldest methodology however is the waterfall methodology. The waterfall methodology had some disadvantages which led most companies to adopt the new agile methodology. Both methodologies use the Software Development Lifecycle (SDLC) but implement it in different ways.</p><p><strong>Software Development Lifecycle(SDLC)</strong></p><p>The software development lifecycle is the steps necessary to create any piece of software. It is made up of 6 separate stages: <strong>Requirements, Analysis, Design, Coding, Testing and Operation</strong></p><blockquote><p><code>Although Agile seems to be the most popular software development methodology now, it doesn&#39;t mean Waterfall methodology is out-dated or has no advantage. For example, if you are trying to build a bridge, do you really want to build a MVP(Minimum Viable Product) first then improve it? The answer is definitely no. You would want build it to a certain standard considering the safety issues and many other problems. So the waterfall would be a better fit in this case.</code></p></blockquote><hr><h2 id="Waterfall-vs-Agile"><a href="#Waterfall-vs-Agile" class="headerlink" title="Waterfall vs Agile"></a>Waterfall vs Agile</h2><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/v2-12223b04c233f2e0ad86123e5aec446a_1440w.jpg" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><hr><h2 id="Agile-Values-Manifesto-敏捷软件开发宣言"><a href="#Agile-Values-Manifesto-敏捷软件开发宣言" class="headerlink" title="Agile Values / Manifesto 敏捷软件开发宣言"></a>Agile Values / Manifesto <strong>敏捷软件开发宣言</strong></h2><ol><li><p><strong><u>Individuals and Interactions</u> over Processes and Tools</strong></p><p><strong><u>个体和互动</u>  高于  流程和工具</strong></p></li><li><p><strong><u>Working Software</u> over Comprehensive Documentation</strong></p><p><strong><u>可工作的软件</u> 高于 详尽的文档</strong></p></li><li><p><strong><u>Customer Collaboration</u> over Contract Negotiation</strong></p><p><strong><u>客户协作</u>  高于  合同谈判</strong></p></li><li><p><strong><u>Responding to Chang</u>e over Following a Plan</strong></p><p><strong><u>响应变化</u> 高于 遵循计划</strong></p></li></ol><hr><h2 id="Agile-Principles-工作原则"><a href="#Agile-Principles-工作原则" class="headerlink" title="Agile Principles 工作原则"></a>Agile Principles 工作原则</h2><ol><li>​    Our highest priority is to satisfy the customer through early and continuous delivery of valuable software.</li><li>​    Welcome changing requirements, even late in development. Agile processes harness change for the customer’s competitive advantage.</li><li>​    Deliver working software frequently, from a couple of weeks to a couple of months, with a preference to the shorter timescale.</li><li>​    Business people and developers must work together daily throughout the project.</li><li>​    Build projects around motivated individuals. Give them the environment and support they need, and trust them to get the job done.</li><li>​    The most efficient and effective method of conveying information to and within a development team is face-to-face conversation.</li><li>​    Working software is the primary measure of progress.</li><li>​    Agile processes promote sustainable development. The sponsors, developers, and users should be able to maintain a constant pace indefinitely.</li><li>​    Continuous attention to technical excellence and good design enhances agility.</li><li>​    Simplicity - the art of maximising the amount of work not done is essential.</li><li>​    The best architectures, requirements, and designs emerge from self-organising teams.</li><li>​    At regular intervals, the team reflects on how to become more effective, then tunes and adjusts its behaviour accordingly.</li></ol><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/v2-c15cd51c61a48138cd4b17579081cf12_1440w.jpg" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><h2 id="Empirical-Process-Control"><a href="#Empirical-Process-Control" class="headerlink" title="Empirical Process Control"></a>Empirical Process Control</h2><blockquote><p>empirical /ɪmˈpɪrɪkl/ 经验主义的</p></blockquote><ol><li>Transparency</li><li>Inspection</li><li>Adaptation</li></ol><h2 id="Scrum-and-other-Common-Agile-development-frameworks"><a href="#Scrum-and-other-Common-Agile-development-frameworks" class="headerlink" title="Scrum and other Common Agile development frameworks"></a>Scrum and other Common Agile development frameworks</h2><blockquote><p><strong>Scrum /skrʌm/</strong>  (英式橄榄球)并列争球，密集争球 In rugby, a scrum is a tight group formed by players from both sides pushing against each other with their heads down in an attempt to get the ball.</p></blockquote><p>Scrum is the most common Agile development framework, others are <strong>Kanban</strong>, XP (eXtreme Programming).</p><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/000.png" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><h2 id="Related-concept-that-might-help-you-understand-the-term-“Working-software”"><a href="#Related-concept-that-might-help-you-understand-the-term-“Working-software”" class="headerlink" title="Related concept that might help you understand the term “Working software”:"></a>Related concept that might help you understand the term “Working software”:</h2><p>The term ‘Working Software’ is kind of like the concept of Minimum Viable Product(MVP) - you build something primitive that actually <strong>work</strong> (may not be perfect) - get feedback - improve it - get feedback -improve it…. :</p><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/J5LPsyNvGP67SQgew229.webp" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p>]]></content>
      
      
      <categories>
          
          <category> Agile </category>
          
          <category> Software Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Agile </tag>
            
            <tag> Scrum </tag>
            
            <tag> Software Development </tag>
            
            <tag> Project Management </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>What is SMB?</title>
      <link href="/posts/34b77a68/"/>
      <url>/posts/34b77a68/</url>
      
        <content type="html"><![CDATA[<h1 id="What-is-SMB"><a href="#What-is-SMB" class="headerlink" title="What is SMB?"></a>What is SMB?</h1><h2 id="SMB-amp-SMB-compliant"><a href="#SMB-amp-SMB-compliant" class="headerlink" title="SMB &amp; SMB-compliant"></a>SMB &amp; SMB-compliant</h2><h3 id="SMB"><a href="#SMB" class="headerlink" title="SMB"></a>SMB</h3><p><strong><u>Server Message Block</u></strong> (<strong>SMB</strong>), one version of which was also known as <u><strong>Common Internet File System</strong></u> (<strong>CIFS</strong> /sɪfs/), is a <strong><u>communication protocol</u></strong> for providing <strong><u>shared access to files, printers, and serial ports between nodes on a network</u></strong>. It also provides an authenticated inter-process communication (IPC) mechanism. Most usage of SMB involves computers running <strong>Microsoft Windows</strong>, where it was known as “Microsoft Windows Network” before the introduction of Active Directory. Corresponding Windows services are LAN Manager Server for the server component, and LAN Manager Workstation for the client component.</p><h3 id="Samba"><a href="#Samba" class="headerlink" title="Samba"></a>Samba</h3><p>In 1991 Andrew Tridgell started the development of Samba, a <strong>free-software</strong> re-implementation (using reverse engineering) of the <strong>SMB/CIFS networking protocol for Unix-like systems</strong>, initially to implement an SMB server to allow PC clients running the DEC Pathworks client to access files on SunOS machines. Because of the importance of the SMB protocol in interacting with the widespread Microsoft Windows platform, <strong>Samba became a popular free software implementation of a compatible SMB client and server to allow non-Windows operating systems, such as Unix-like operating systems, to interoperate with Windows.</strong> </p><h3 id="什么是SMB"><a href="#什么是SMB" class="headerlink" title="什么是SMB"></a>什么是SMB</h3><p><strong>SMB</strong>(全称是 <strong><u>Server Message Block</u></strong> )是一个<strong>协议名</strong>，它能 <strong><u>被用于Web连接和客户端与服务器之间的信息沟通</u></strong> 。SMB最初是IBM的贝瑞·费根鲍姆（Barry Feigenbaum）研制的，其目的是将DOS操作系统中的本地文件接口“中断13”改造为网络文件系统。</p><h4 id="研究背景"><a href="#研究背景" class="headerlink" title="研究背景"></a>研究背景</h4><p>随着网络通信技术和网络资源共享机制的不断发展，针对网络间支持数据共享的协议和机制等技术的研究受到了研究人员的广泛关注。其中，网络文件共享传输过程的安全性研究更是成为该领域的热点问题。其中，SMB（ServerMessageBlock）协议作为一种局域网文件共享传输协议，常被用来作为共享文件安全传输研究的平台。但是，SMB协议中采用控制文件安全传输的机制是使用客户身份验证的方式，该方式通过客户端向服务器端发送验证密码来获取文件传输的权限，不过针对该机制的网络攻击相对严重，攻击程序通过对验证密码的截获来窃取文件的访问权限，局域网下文件传输的安全性得不到保障.</p><h4 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h4><p>SMB协议可以为局域网用户提供相关的功能和机制，来保证传输的可靠性。局域网中90%的数据包以及95%的字节是通过SMB协议进行传输，这是为了解决网络的稳定性和数据流在共享带宽时的公平性、拥塞控制及效率等问题。由于SMB传输应用的普遍性和重要性，关于SMB传输这一课题计算机领域中很多学者致力于这一方面潜心研究，就SMB协议及其多个版本在各类网络下的传输效率问题做了大量的研究和实验。在局域网发展之初该网内的文件共享是通过FTP协议进行传输。用户必须首先从服务器下载该文件的数据到本地（客户端），然后对数据文件进行修改操作，之后，用户重新将客户端的文件上传到FTP服务器中，但是用户不能直接对FTP上的数据信息等进行修改操作。如果用户在该过程中对文件进行了修改操作，但并没有将修改后的文件上传到FTP服务器，那么之后申请读取该文件的用户就无法下载最新的文件。</p><p>1984年，安德鲁Tridgwell曾遇到这样的问题，他用三台个人电脑都运行DOS系统，通过电脑计算机DEC的Unix数字系统以及Sun公司的Unix系统进行试验。当时，安德鲁Tridgwell写了一个程序，以检测通信协议在DEC的Unix系统下计算机处理哪些信息，在信息传输过程中，对程序中的相关参数进行更改，便可读取来自不同计算机的信息文件等内容，进而实现了计算之间的信息数据的互通。通过这种方式他们发现了一种可以进行操作系统之间信息通信的协议，并在此协议的基础上进行改进，将改进后的协议命名为SMB协议，该协议的文件传输系统可以实现不同操作系统间文件和信息的共享。在这之后，安德鲁Tridgwell开始应用SMB服务器作为软件的注册商标。这是SMB的由来。为了能够在不同的Windows主机设备之间实现共享文件数据的目的，便出现了更高版本的SMB协议。但最常见的（在Windows98，WindowsNT中，Windows2000和XP）是NTLM0.12版本。SMB协议可以实现相邻网络中间的计算机中文件的共享功能，该协议包含两部分分别是服务器端和客户端，它通过网络中的TCP、NetBEUI等通信协议建立会话连接，然后用户可以通过该协议的客户端发起文件共享请求，并通过服务器接收到的请求将文件发送给用户来实现文件的共享。</p><p>SMB1.0协议由于在文件共享传输过程中存在的传输效率低以及传输空间小等缺陷被人们所摒弃。为了更好的实现网络中文件的共享过程，在SMB1.0的基础上开发了新的网络文件传输协议，并将其命名为SMB2.0。该协议在实现了文件共享传输的基本功能的基础上对文件传输的效率、文件缓存的空间以及文件并发传输等问题进行改进，使得在局域网或更高配置的网络环境下，文件传输过程的速度和效率等得到了很大的提升。并且，由于对于SMB研究领域已经出现了可以对该文件共享过程进行信息截取等恶意攻击方法，故而在SMB版本更新的过程中加入了对文件传输过程的安全性保障机制。在对SMB协议的研究过程中，很多文献均选择对文件传输效率等问题进行改进，但是对该协议的本质内容并没有做改变，其主要原因是SMB协议自身的复杂性和其对操作系统的依赖性。但是，正是由于SMB依赖于操作系统等底层的架构，所以对于文件的传输等过程的控制和性能提升等操作可以通过它所依赖的底层系统来进行修改，进而达到对文件传输过程的控制和优化。</p><h4 id="SMB协议"><a href="#SMB协议" class="headerlink" title="SMB协议"></a>SMB协议</h4><p>后来微软对这个发展进行了重大更改，这个更改后的版本也是最常见的版本。微软将SMB协议与它和3Com一起发展的网络管理程序结合在一起，并在Windows for Workgroups和后来的Windows版本中不断加入新的功能。<br>SMB一开始的设计是在NetBIOS协议上运行的（而NetBIOS本身则运行在NetBEUI、IPX/SPX或TCP/IP协议上），Windows 2000引入了SMB直接在TCP/IP上运行的功能。在这里我们必须区分SMB协议和运行在这个协议上的SMB业务，以及NetBIOS和使用SMB作为认证隧道的DCE/RPC业务。此外我们还要区分主要（但不仅仅）直接使用NetBIOS数据报的“网络邻居”协议。<br>1996年，Sun推出WebNFS的同时，微软提出将SMB改称为Common Internet File System。此外微软还加入了许多新的功能，比如符号链接、硬链接、提高文件的大小。微软还试图支持直接联系，不依靠NetBIOS，不过这个试图依然处于尝试阶段，并需要继续完善。微软向互联网工程工作小组提出了部分定义作为互联网草案[3]。不过这些提案均已过期。<br>由于SMB协议对于与占主要地位的Microsoft Windows平台通讯时的重要性，而该平台使用的SMB协议与初始的版本相比有巨大的改变，因此Samba项目就是被创立来逆向工程来提供一个与SMB软件兼容的自由软件，使得非微软操作系统也能够使用它。<br>在Windows Vista中微软又推出了Server Message Block 2.0。</p><h4 id="SMB3-0"><a href="#SMB3-0" class="headerlink" title="SMB3.0"></a>SMB3.0</h4><p>服务器信息块（SMB）是一个网络文件共享协议，它允许应用程序和终端用户从远端的文件服务器访问文件资源。微软最初将SMB定位为Windows Server 2008和Vista系统中通用互联网文件系统（CIFS）的后续产品。最新版本的SMB 3.0在Windows Server 2012操作系统中出现，并且与Windows 8客户端共同工作。<br>SMB 3.0极大的提升了性能、可靠性和安全性。具体来说，当它与Windows Storage Spaces（Windows Server 2012的一个功能，将普通的硬盘虚拟化为高性能、高可用性的存储）结合时，SMB 3.0可以使用廉价的直连存储（DAS）、JBOD或RBOD，创建一个特定的NAS设备（或SAN存储阵列）。IT组织可以因此在不购买昂贵的SAN存储的情况下得到企业级存储的特性，而且管理也变得更加简单。此外，SMB 3.0支持一些以前只在块存储环境下才可以使用的应用程序，如SQL Server。</p><h4 id="IBM-SMB"><a href="#IBM-SMB" class="headerlink" title="IBM SMB"></a>IBM SMB</h4><p><strong>（IBM SMB：Server Message Block protocol）</strong><br><strong>服务器信息块（SMB）协议是一种IBM协议，用于在计算机间共享文件、打印机、串口等。SMB 协议可以用在因特网的TCP/IP协议之上，也可以用在其它网络协议如IPX和NetBEUI 之上。</strong><br><strong>SMB 一种客户机/服务器、请求/响应协议。通过 SMB 协议，客户端应用程序可以在各种网络环境下读、写服务器上的文件，以及对服务器程序提出服务请求。此外通过 SMB 协议，应用程序可以访问远程服务器端的文件、以及打印机、邮件槽（mailslot）、命名管道（named pipe）等资源。</strong><br><strong>在 TCP/IP 环境下，客户机通过 NetBIOS over TCP/IP（或 NetBEUI/TCP 或 SPX/IPX）连接服务器。一旦连接成功，客户机可发送 SMB 命令到服务器上，从而客户机能够访问共享目录、打开文件、读写文件，以及一切在文件系统上能做的所有事情。</strong><br><strong>从 Windows 95 开始，Microsoft Windows 操作系统（operating system）都包括了客户机和服务器 SMB 协议支持。Microsoft 为 Internet 提供了 SMB 的开源版本，即通用 Internet 文件系统 （CIFS）。与现有 Internet 应用程序如文件传输协议（FTP）相比， CIFS 灵活性更大。对于 UNIX 系统，可使用一种称为 Samba 的共享软件。</strong></p><h2 id="References"><a href="#References" class="headerlink" title="References:"></a>References:</h2><p><a href="https://en.wikipedia.org/wiki/Server_Message_Block">https://en.wikipedia.org/wiki/Server_Message_Block</a></p><p><a href="https://baike.baidu.com/item/smb/4750512?fr=aladdin">https://baike.baidu.com/item/smb/4750512?fr=aladdin</a></p>]]></content>
      
      
      <categories>
          
          <category> Azure </category>
          
          <category> Data Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Azure </tag>
            
            <tag> Data Storage </tag>
            
            <tag> SMB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>What is &#39;Redundant&#39; Data?</title>
      <link href="/posts/38dbfa3f/"/>
      <url>/posts/38dbfa3f/</url>
      
        <content type="html"><![CDATA[<h1 id="What-is-‘Redundant’-Data"><a href="#What-is-‘Redundant’-Data" class="headerlink" title="What is ‘Redundant’ Data?"></a>What is ‘Redundant’ Data?</h1><h2 id="Redundant-Data"><a href="#Redundant-Data" class="headerlink" title="Redundant Data"></a>Redundant Data</h2><p>When it comes to Data Storage, the word ‘redundant’ or ‘ redundancy’ keeps popping up. So what is data redundancy? </p><p>Data redundancy / Redundant data occurs when <strong>the same piece of data exists in multiple places</strong>.</p><p>Human Word Version(Life examples):</p><p>For example: If every shopping record attaches an individual customer data, even they are actually the Same Customer, therefore this will cause Data Redundancy.</p><p>Another simple example is : you store your notes on your computer with Microsoft Word, and the author will always be yourself, but the Word will record you as Author every time in every doc file. So the Author Name in this case would be the redundant data.</p><hr><h2 id="数据冗余"><a href="#数据冗余" class="headerlink" title="数据冗余"></a>数据冗余</h2><p>数据冗余发生在数据库系统中，指的是一个字段在多个表里重复出现。举个例子，如果每条客户购买商品的信息里都连带记录了客户自身的信息，这样的数据冗余可能造成不一致，因为客户自身的信息可能不一样。数据冗余会导致数据异常和损坏，一般来说设计上应该被避免。数据库规范化防止了冗余而且不浪费存储容量。</p><p>适当的使用外键可以使得数据冗余和异常降到最低。但是，如果考虑效率和便利，有时候也会设计冗余数据，而不考虑数据被破坏的风险。</p>]]></content>
      
      
      <categories>
          
          <category> Azure </category>
          
          <category> Data Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redundant </tag>
            
            <tag> Redundancy </tag>
            
            <tag> Data Storage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>What is Container &amp; Docker?</title>
      <link href="/posts/c9b9b3e2/"/>
      <url>/posts/c9b9b3e2/</url>
      
        <content type="html"><![CDATA[<h1 id="What-is-Container-amp-Docker"><a href="#What-is-Container-amp-Docker" class="headerlink" title="What is Container &amp; Docker?"></a>What is Container &amp; Docker?</h1><h2 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h2><h3 id="What-is-Container"><a href="#What-is-Container" class="headerlink" title="What is Container?"></a>What is Container?</h3><p>A container is <strong><u>a standard unit of software</u> that packages up code and all its dependencies</strong> so the application runs quickly and reliably from one computing environment to another.</p><p><strong>Human language Version</strong>😂:</p><p>Imagine the term ‘Container’ is an actual container in life:</p><p><img "" class="lazyload placeholder" data-original="https://cdn.pixabay.com/photo/2016/11/21/13/20/port-1845350_1280.jpg" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><p>In the old days, if you want to build an app, you have to start from deploying a system such as VM, and different VM(such as Windows &amp; Linux) makes it harder to transfer the app from one system to another.</p><p>Therefore, containers are a solution to the problem of <strong>how to get software to run reliably when <u>moved from one computing environment to another</u>.</strong> </p><p><u><strong>A container consists of an entire runtime environment except they don’t include the operating system: an application, plus all its dependencies, libraries and other binaries, and configuration files needed to run it, bundled into one package.</strong></u> By containerizing the application platform and its dependencies, differences in OS distributions and underlying infrastructure are abstracted away.</p><p><code>In this case:  Different systems are like different quays. And Containers is like actual containers. If you wanna move the containers from Shanghai Quay(Windows) to London Quay(Linux), the containers will not be affected and easy to transfer.</code></p><h4 id="Benefits-of-Container"><a href="#Benefits-of-Container" class="headerlink" title="Benefits of Container:"></a>Benefits of Container:</h4><p>A container may be only tens of megabytes in size, whereas a virtual machine with its own entire operating system may be several gigabytes in size. Because of this, a single server can host far more containers than virtual machines.</p><p>Another major benefit is that virtual machines may take several minutes to boot up their operating systems and begin running the applications they host, while containerized applications can be started almost instantly. That means containers can be instantiated in a “just in time” fashion when they are needed and can disappear when they are no longer required, freeing up resources on their hosts.</p><p>A third benefit is that containerization allows for greater modularity. Rather than run an entire complex application inside a single container, the application can be split in to modules (such as the database, the application front end, and so on). This is the so-called microservices approach.  Applications built in this way are easier to manage because each module is relatively simple, and changes can be made to modules without having to rebuild the entire application. Because containers are so lightweight, individual modules (or microservices) can be instantiated only when they are needed and are available almost immediately.</p><hr><h3 id="什么是容器（Container）"><a href="#什么是容器（Container）" class="headerlink" title="什么是容器（Container）?"></a>什么是容器（Container）?</h3><p>早期，大家都认为硬件抽象层基于hypervisor的虚拟化方式可以最大程度上提供虚拟化管理的灵活性。各种不同操作系统的虚拟机都能通过hypervisor（KVM、XEN等）来衍生、运行、销毁。然而，随着时间推移，用户发现hypervisor这种方式麻烦越来越多。为什么？因为对于hypervisor环境来说，<strong>每个虚拟机都需要运行一个完整的操作系统以及其中安装好的大量应用程序</strong>。但实际生产开发环境里，我们更关注的是自己部署的应用程序，如果每次部署发布我都得搞一个完整操作系统和附带的依赖环境，那么这让任务和性能变得很重和很低下。</p><p>基于上述情况，人们就在想，有没有其他什么方式能让人更加的关注应用程序本身，底层多余的操作系统和环境我可以共享和复用？<strong>换句话来说，那就是<u>我部署一个服务运行好后，我再想移植到另外一个地方，我可以不用再安装一套操作系统和依赖环境</u>。</strong>这就像集装箱运载一样，我把货物一辆兰博基尼跑车（好比开发好的应用APP），打包放到一容器集装箱里，它通过货轮可以轻而易举的从上海码头（CentOS7.2环境）运送到纽约码头（Ubuntu14.04环境）。而且运输期间，我的兰博基尼（APP）没有受到任何的损坏（文件没有丢失），在另外一个码头卸货后，依然可以完美风骚的赛跑（启动正常）。</p><p>Linux Container容器技术的诞生（2008年）就解决了IT世界里“集装箱运输”的问题。Linux Container（简称LXC）它是一种内核轻量级的操作系统层虚拟化技术。Linux Container主要由Namespace和Cgroup两大机制来保证实现。那么Namespace和Cgroup是什么呢？刚才我们上面提到了集装箱，集装箱的作用当然是可以对货物进行打包隔离了，不让A公司的货跟B公司的货混在一起，不然卸货就分不清楚了。那么Namespace也是一样的作用，做隔离。光有隔离还没用，我们还需要对货物进行资源的管理。同样的，航运码头也有这样的管理机制：货物用什么样规格大小的集装箱，货物用多少个集装箱，货物哪些优先运走，遇到极端天气怎么暂停运输服务怎么改航道等等… 通用的，与此对应的Cgroup就负责资源管理控制作用，比如进程组使用CPU/MEM的限制，进程组的优先级控制，进程组的挂起和恢复等等。</p><p>Linux Container容器技术的诞生（2008年）就解决了IT世界里“集装箱运输”的问题。Linux Container（简称LXC）它是一种内核轻量级的操作系统层虚拟化技术。Linux Container主要由Namespace和Cgroup两大机制来保证实现。那么Namespace和Cgroup是什么呢？刚才我们上面提到了集装箱，集装箱的作用当然是可以对货物进行打包隔离了，不让A公司的货跟B公司的货混在一起，不然卸货就分不清楚了。那么Namespace也是一样的作用，做隔离。光有隔离还没用，我们还需要对货物进行资源的管理。同样的，航运码头也有这样的管理机制：货物用什么样规格大小的集装箱，货物用多少个集装箱，货物哪些优先运走，遇到极端天气怎么暂停运输服务怎么改航道等等… 通用的，与此对应的Cgroup就负责资源管理控制作用，比如进程组使用CPU/MEM的限制，进程组的优先级控制，进程组的挂起和恢复等等。</p><hr><h4 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h4><p>容器的特点其实我们拿跟它跟硬件抽象层虚拟化hypervisor技术对比就清楚了，我们之前也提到过，传统的虚拟化（虚拟机）技术，创建环境和部署应用都很麻烦，而且应用的移植性也很繁琐，比如你要把vmware里的虚拟机迁移到KVM里就很繁琐（需要做镜像格式的转换）。那么有了容器技术就简单了，总结下容器技术主要有三个特点：</p><pre><code>1. 极其轻量：只打包了必要的Bin/Lib；2. 秒级部署：根据镜像的不同，容器的部署大概在毫秒与秒之间（比虚拟机强很多）；3. 易于移植：一次构建，随处部署；4. 弹性伸缩：Kubernetes、Swam、Mesos这类开源、方便、好使的容器管理平台有着非常强大的弹性管理能力。</code></pre><h2 id="What-is-Docker"><a href="#What-is-Docker" class="headerlink" title="What is Docker?"></a>What is Docker?</h2><h3 id="What-is-Docker-1"><a href="#What-is-Docker-1" class="headerlink" title="What is Docker?"></a>What is Docker?</h3><p>Docker is <u><strong>not</strong> equal</u> to Container. It’s just <u>one of the platforms</u> that can deliver containers.</p><p><strong>Docker is a set of platform as a service products that use OS-level virtualization to deliver software in packages called containers.</strong> </p><hr><h3 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker?"></a>什么是Docker?</h3><p>当前，docker几乎是容器的代名词，很多人以为docker就是容器。其实，这是错误的认识，除了docker  还有coreos。所以，容器世界里并不是只有docker一家。既然不是一家就很容易出现分歧。任何技术出现都需要一个标准来规范它，不然各搞各的很容易导致技术实现的碎片化，出现大量的冲突和冗余。因此，在2015年，由Google，Docker、CoreOS、IBM、微软、红帽等厂商联合发起的OCI（Open Container  Initiative）组织成立了，并于2016年4月推出了第一个开放容器标准。标准主要包括runtime运行时标准和image镜像标准。标准的推出，有助于替成长中市场带来稳定性，让企业能放心采用容器技术，用户在打包、部署应用程序后，可以自由选择不同的容器Runtime；同时，镜像打包、建立、认证、部署、命名也都能按照统一的规范来做。</p><p>两种标准主要包含以下内容：</p><p><code>1.容器运行时标准 （runtime spec）</code></p><p>a). creating：使用 create 命令创建容器，这个过程称为创建中 b). created：容器创建出来，但是还没有运行，表示镜像和配置没有错误，容器能够运行在当前平台 c). running：容器的运行状态，里面的进程处于 up 状态，正在执行用户设定的任务 d). stopped：容器运行完成，或者运行出错，或者 stop 命令之后，容器处于暂停状态。这个状态，容器还有很多信息保存在平台中，并没有完全被删除</p><p><code>2.容器镜像标准（image spec）</code></p><p>a). 文件系统：以 layer 保存的文件系统，每个 layer 保存了和上层之间变化的部分，layer 应该保存哪些文件，怎么表示增加、修改和删除的文件等; b). config 文件：保存了文件系统的层级信息（每个层级的 hash 值，以及历史信息），以及容器运行时需要的一些信息（比如环境变量、工作目录、命令参数、mount 列表），指定了镜像在某个特定平台和系统的配置。比较接近我们使用 docker inspect <image_id> 看到的内容; c). manifest 文件：镜像的 config 文件索引，有哪些 layer，额外的 annotation 信息，manifest 文件中保存了很多和当前平台有关的信息; d). index 文件：可选的文件，指向不同平台的 manifest 文件，这个文件能保证一个镜像可以跨平台使用，每个平台拥有不同的 manifest 文件，使用 index 作为索引。</p><h2 id="Related-Quiz"><a href="#Related-Quiz" class="headerlink" title="Related Quiz:"></a>Related Quiz:</h2><p>Q: Which service simplifies the process of configuring, deploying, and  managing a simple containerized application on the Azure cloud?</p><ol><li><p>Azure Container Instances</p></li><li><p>Azure Functions</p></li><li><p>Azure App Service</p></li><li><p>Azure Pipelines</p></li></ol><p>A: Azure Container Instances</p><p>Containers are somewhat like virtual machines except they don’t include the operating system. This makes it easy to deploy them because they’re very lightweight compared to virtual machines. In fact, containers run on virtual machines.</p><p>Microsoft provides a variety of ways to run containers. The simplest way is to use Azure Container Instances. This service lets you run a container using a single command.</p><hr><p>Q: What Azure Cloud compute service is useful when planning a ‘lift-and-shift” migration of an application from an on-premises environment to the Azure Cloud?</p><ol><li><p>Azure Virtual Machines</p></li><li><p>Azure Functions</p></li><li><p>Azure Container Instances</p></li><li><p>Azure DevOps</p></li></ol><p>A: Azure Container Instances</p><p>If you currently have an application running on a Windows or Linux server, then the most straightforward way to migrate it to Azure is to do what’s called a “lift and shift” migration. That is, you simply lift the application from your on-premises server and shift it to a virtual server in the cloud. Azure VMs are known as Infrastructure-as-a-Service because they’re traditional IT infrastructure components that are offered as a service.</p><h2 id="References-amp-Credit："><a href="#References-amp-Credit：" class="headerlink" title="References &amp; Credit："></a>References &amp; Credit：</h2><p><a href="https://www.cnblogs.com/qcloud1001/p/9273549.html">https://www.cnblogs.com/qcloud1001/p/9273549.html</a></p><p><a href="https://www.cio.com/article/2924995/what-are-containers-and-why-do-you-need-them.html">https://www.cio.com/article/2924995/what-are-containers-and-why-do-you-need-them.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Azure </category>
          
          <category> Data Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Container </tag>
            
            <tag> Docker </tag>
            
            <tag> Azure </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
