<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Agile</title>
      <link href="/posts/b6d6088d/"/>
      <url>/posts/b6d6088d/</url>
      
        <content type="html"><![CDATA[<h1 id="Agile-敏捷项目管理"><a href="#Agile-敏捷项目管理" class="headerlink" title="Agile  敏捷项目管理"></a>Agile  敏捷项目管理</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>Agile/ˈædʒaɪl/ is the most common <strong>software development</strong> methodology - it is an <strong>iterative</strong>(/‘ɪtərətɪv/<strong>迭代式</strong>) methodology to create software. The simplest and oldest methodology however is the waterfall methodology. The waterfall methodology had some disadvantages which led most companies to adopt the new agile methodology. Both methodologies use the Software Development Lifecycle (SDLC) but implement it in different ways.</p><p><strong>Software Development Lifecycle(SDLC)</strong></p><p>The software development lifecycle is the steps necessary to create any piece of software. It is made up of 6 separate stages: <strong>Requirements, Analysis, Design, Coding, Testing and Operation</strong></p><blockquote><p><code>Although Agile seems to be the most popular software development methodology now, it doesn&#39;t mean Waterfall methodology is out-dated or has no advantage. For example, if you are trying to build a bridge, do you really want to build a MVP(Minimum Viable Product) first then improve it? The answer is definitely no. You would want build it to a certain standard considering the safety issues and many other problems. So the waterfall would be a better fit in this case.</code></p></blockquote><hr><h2 id="Waterfall-vs-Agile"><a href="#Waterfall-vs-Agile" class="headerlink" title="Waterfall vs Agile"></a>Waterfall vs Agile</h2><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/v2-12223b04c233f2e0ad86123e5aec446a_1440w.jpg" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><hr><h2 id="Agile-Values-Manifesto-敏捷软件开发宣言"><a href="#Agile-Values-Manifesto-敏捷软件开发宣言" class="headerlink" title="Agile Values / Manifesto 敏捷软件开发宣言"></a>Agile Values / Manifesto <strong>敏捷软件开发宣言</strong></h2><ol><li><p><strong><u>Individuals and Interactions</u> over Processes and Tools</strong></p><p><strong><u>个体和互动</u>  高于  流程和工具</strong></p></li><li><p><strong><u>Working Software</u> over Comprehensive Documentation</strong></p><p><strong><u>可工作的软件</u> 高于 详尽的文档</strong></p></li><li><p><strong><u>Customer Collaboration</u> over Contract Negotiation</strong></p><p><strong><u>客户协作</u>  高于  合同谈判</strong></p></li><li><p><strong><u>Responding to Chang</u>e over Following a Plan</strong></p><p><strong><u>响应变化</u> 高于 遵循计划</strong></p></li></ol><hr><h2 id="Agile-Principles-工作原则"><a href="#Agile-Principles-工作原则" class="headerlink" title="Agile Principles 工作原则"></a>Agile Principles 工作原则</h2><ol><li>​    Our highest priority is to satisfy the customer through early and continuous delivery of valuable software.</li><li>​    Welcome changing requirements, even late in development. Agile processes harness change for the customer’s competitive advantage.</li><li>​    Deliver working software frequently, from a couple of weeks to a couple of months, with a preference to the shorter timescale.</li><li>​    Business people and developers must work together daily throughout the project.</li><li>​    Build projects around motivated individuals. Give them the environment and support they need, and trust them to get the job done.</li><li>​    The most efficient and effective method of conveying information to and within a development team is face-to-face conversation.</li><li>​    Working software is the primary measure of progress.</li><li>​    Agile processes promote sustainable development. The sponsors, developers, and users should be able to maintain a constant pace indefinitely.</li><li>​    Continuous attention to technical excellence and good design enhances agility.</li><li>​    Simplicity - the art of maximising the amount of work not done is essential.</li><li>​    The best architectures, requirements, and designs emerge from self-organising teams.</li><li>​    At regular intervals, the team reflects on how to become more effective, then tunes and adjusts its behaviour accordingly.</li></ol><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/v2-c15cd51c61a48138cd4b17579081cf12_1440w.jpg" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><h2 id="Empirical-Process-Control"><a href="#Empirical-Process-Control" class="headerlink" title="Empirical Process Control"></a>Empirical Process Control</h2><blockquote><p>empirical /ɪmˈpɪrɪkl/ 经验主义的</p></blockquote><ol><li>Transparency</li><li>Inspection</li><li>Adaptation</li></ol><h2 id="Scrum-and-other-Common-Agile-development-frameworks"><a href="#Scrum-and-other-Common-Agile-development-frameworks" class="headerlink" title="Scrum and other Common Agile development frameworks"></a>Scrum and other Common Agile development frameworks</h2><blockquote><p><strong>Scrum /skrʌm/</strong>  (英式橄榄球)并列争球，密集争球 In rugby, a scrum is a tight group formed by players from both sides pushing against each other with their heads down in an attempt to get the ball.</p></blockquote><p>Scrum is the most common Agile development framework, others are <strong>Kanban</strong>, XP (eXtreme Programming).</p><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/000.png" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><h2 id="Related-concept-that-might-help-you-understand-the-term-“Working-software”"><a href="#Related-concept-that-might-help-you-understand-the-term-“Working-software”" class="headerlink" title="Related concept that might help you understand the term “Working software”:"></a>Related concept that might help you understand the term “Working software”:</h2><p>The term ‘Working Software’ is kind of like the concept of Minimum Viable Product(MVP) - you build something primitive that actually <strong>work</strong> (may not be perfect) - get feedback - improve it - get feedback -improve it…. :</p><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/J5LPsyNvGP67SQgew229.webp" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p>]]></content>
      
      
      <categories>
          
          <category> Agile </category>
          
          <category> Software Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Agile </tag>
            
            <tag> Scrum </tag>
            
            <tag> Software Development </tag>
            
            <tag> Project Management </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>What is SMB?</title>
      <link href="/posts/34b77a68/"/>
      <url>/posts/34b77a68/</url>
      
        <content type="html"><![CDATA[<h1 id="What-is-SMB"><a href="#What-is-SMB" class="headerlink" title="What is SMB?"></a>What is SMB?</h1><h2 id="SMB-amp-SMB-compliant"><a href="#SMB-amp-SMB-compliant" class="headerlink" title="SMB &amp; SMB-compliant"></a>SMB &amp; SMB-compliant</h2><h3 id="SMB"><a href="#SMB" class="headerlink" title="SMB"></a>SMB</h3><p><strong><u>Server Message Block</u></strong> (<strong>SMB</strong>), one version of which was also known as <u><strong>Common Internet File System</strong></u> (<strong>CIFS</strong> /sɪfs/), is a <strong><u>communication protocol</u></strong> for providing <strong><u>shared access to files, printers, and serial ports between nodes on a network</u></strong>. It also provides an authenticated inter-process communication (IPC) mechanism. Most usage of SMB involves computers running <strong>Microsoft Windows</strong>, where it was known as “Microsoft Windows Network” before the introduction of Active Directory. Corresponding Windows services are LAN Manager Server for the server component, and LAN Manager Workstation for the client component.</p><h3 id="Samba"><a href="#Samba" class="headerlink" title="Samba"></a>Samba</h3><p>In 1991 Andrew Tridgell started the development of Samba, a <strong>free-software</strong> re-implementation (using reverse engineering) of the <strong>SMB/CIFS networking protocol for Unix-like systems</strong>, initially to implement an SMB server to allow PC clients running the DEC Pathworks client to access files on SunOS machines. Because of the importance of the SMB protocol in interacting with the widespread Microsoft Windows platform, <strong>Samba became a popular free software implementation of a compatible SMB client and server to allow non-Windows operating systems, such as Unix-like operating systems, to interoperate with Windows.</strong> </p><h3 id="什么是SMB"><a href="#什么是SMB" class="headerlink" title="什么是SMB"></a>什么是SMB</h3><p><strong>SMB</strong>(全称是 <strong><u>Server Message Block</u></strong> )是一个<strong>协议名</strong>，它能 <strong><u>被用于Web连接和客户端与服务器之间的信息沟通</u></strong> 。SMB最初是IBM的贝瑞·费根鲍姆（Barry Feigenbaum）研制的，其目的是将DOS操作系统中的本地文件接口“中断13”改造为网络文件系统。</p><h4 id="研究背景"><a href="#研究背景" class="headerlink" title="研究背景"></a>研究背景</h4><p>随着网络通信技术和网络资源共享机制的不断发展，针对网络间支持数据共享的协议和机制等技术的研究受到了研究人员的广泛关注。其中，网络文件共享传输过程的安全性研究更是成为该领域的热点问题。其中，SMB（ServerMessageBlock）协议作为一种局域网文件共享传输协议，常被用来作为共享文件安全传输研究的平台。但是，SMB协议中采用控制文件安全传输的机制是使用客户身份验证的方式，该方式通过客户端向服务器端发送验证密码来获取文件传输的权限，不过针对该机制的网络攻击相对严重，攻击程序通过对验证密码的截获来窃取文件的访问权限，局域网下文件传输的安全性得不到保障.</p><h4 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h4><p>SMB协议可以为局域网用户提供相关的功能和机制，来保证传输的可靠性。局域网中90%的数据包以及95%的字节是通过SMB协议进行传输，这是为了解决网络的稳定性和数据流在共享带宽时的公平性、拥塞控制及效率等问题。由于SMB传输应用的普遍性和重要性，关于SMB传输这一课题计算机领域中很多学者致力于这一方面潜心研究，就SMB协议及其多个版本在各类网络下的传输效率问题做了大量的研究和实验。在局域网发展之初该网内的文件共享是通过FTP协议进行传输。用户必须首先从服务器下载该文件的数据到本地（客户端），然后对数据文件进行修改操作，之后，用户重新将客户端的文件上传到FTP服务器中，但是用户不能直接对FTP上的数据信息等进行修改操作。如果用户在该过程中对文件进行了修改操作，但并没有将修改后的文件上传到FTP服务器，那么之后申请读取该文件的用户就无法下载最新的文件。</p><p>1984年，安德鲁Tridgwell曾遇到这样的问题，他用三台个人电脑都运行DOS系统，通过电脑计算机DEC的Unix数字系统以及Sun公司的Unix系统进行试验。当时，安德鲁Tridgwell写了一个程序，以检测通信协议在DEC的Unix系统下计算机处理哪些信息，在信息传输过程中，对程序中的相关参数进行更改，便可读取来自不同计算机的信息文件等内容，进而实现了计算之间的信息数据的互通。通过这种方式他们发现了一种可以进行操作系统之间信息通信的协议，并在此协议的基础上进行改进，将改进后的协议命名为SMB协议，该协议的文件传输系统可以实现不同操作系统间文件和信息的共享。在这之后，安德鲁Tridgwell开始应用SMB服务器作为软件的注册商标。这是SMB的由来。为了能够在不同的Windows主机设备之间实现共享文件数据的目的，便出现了更高版本的SMB协议。但最常见的（在Windows98，WindowsNT中，Windows2000和XP）是NTLM0.12版本。SMB协议可以实现相邻网络中间的计算机中文件的共享功能，该协议包含两部分分别是服务器端和客户端，它通过网络中的TCP、NetBEUI等通信协议建立会话连接，然后用户可以通过该协议的客户端发起文件共享请求，并通过服务器接收到的请求将文件发送给用户来实现文件的共享。</p><p>SMB1.0协议由于在文件共享传输过程中存在的传输效率低以及传输空间小等缺陷被人们所摒弃。为了更好的实现网络中文件的共享过程，在SMB1.0的基础上开发了新的网络文件传输协议，并将其命名为SMB2.0。该协议在实现了文件共享传输的基本功能的基础上对文件传输的效率、文件缓存的空间以及文件并发传输等问题进行改进，使得在局域网或更高配置的网络环境下，文件传输过程的速度和效率等得到了很大的提升。并且，由于对于SMB研究领域已经出现了可以对该文件共享过程进行信息截取等恶意攻击方法，故而在SMB版本更新的过程中加入了对文件传输过程的安全性保障机制。在对SMB协议的研究过程中，很多文献均选择对文件传输效率等问题进行改进，但是对该协议的本质内容并没有做改变，其主要原因是SMB协议自身的复杂性和其对操作系统的依赖性。但是，正是由于SMB依赖于操作系统等底层的架构，所以对于文件的传输等过程的控制和性能提升等操作可以通过它所依赖的底层系统来进行修改，进而达到对文件传输过程的控制和优化。</p><h4 id="SMB协议"><a href="#SMB协议" class="headerlink" title="SMB协议"></a>SMB协议</h4><p>后来微软对这个发展进行了重大更改，这个更改后的版本也是最常见的版本。微软将SMB协议与它和3Com一起发展的网络管理程序结合在一起，并在Windows for Workgroups和后来的Windows版本中不断加入新的功能。<br>SMB一开始的设计是在NetBIOS协议上运行的（而NetBIOS本身则运行在NetBEUI、IPX/SPX或TCP/IP协议上），Windows 2000引入了SMB直接在TCP/IP上运行的功能。在这里我们必须区分SMB协议和运行在这个协议上的SMB业务，以及NetBIOS和使用SMB作为认证隧道的DCE/RPC业务。此外我们还要区分主要（但不仅仅）直接使用NetBIOS数据报的“网络邻居”协议。<br>1996年，Sun推出WebNFS的同时，微软提出将SMB改称为Common Internet File System。此外微软还加入了许多新的功能，比如符号链接、硬链接、提高文件的大小。微软还试图支持直接联系，不依靠NetBIOS，不过这个试图依然处于尝试阶段，并需要继续完善。微软向互联网工程工作小组提出了部分定义作为互联网草案[3]。不过这些提案均已过期。<br>由于SMB协议对于与占主要地位的Microsoft Windows平台通讯时的重要性，而该平台使用的SMB协议与初始的版本相比有巨大的改变，因此Samba项目就是被创立来逆向工程来提供一个与SMB软件兼容的自由软件，使得非微软操作系统也能够使用它。<br>在Windows Vista中微软又推出了Server Message Block 2.0。</p><h4 id="SMB3-0"><a href="#SMB3-0" class="headerlink" title="SMB3.0"></a>SMB3.0</h4><p>服务器信息块（SMB）是一个网络文件共享协议，它允许应用程序和终端用户从远端的文件服务器访问文件资源。微软最初将SMB定位为Windows Server 2008和Vista系统中通用互联网文件系统（CIFS）的后续产品。最新版本的SMB 3.0在Windows Server 2012操作系统中出现，并且与Windows 8客户端共同工作。<br>SMB 3.0极大的提升了性能、可靠性和安全性。具体来说，当它与Windows Storage Spaces（Windows Server 2012的一个功能，将普通的硬盘虚拟化为高性能、高可用性的存储）结合时，SMB 3.0可以使用廉价的直连存储（DAS）、JBOD或RBOD，创建一个特定的NAS设备（或SAN存储阵列）。IT组织可以因此在不购买昂贵的SAN存储的情况下得到企业级存储的特性，而且管理也变得更加简单。此外，SMB 3.0支持一些以前只在块存储环境下才可以使用的应用程序，如SQL Server。</p><h4 id="IBM-SMB"><a href="#IBM-SMB" class="headerlink" title="IBM SMB"></a>IBM SMB</h4><p><strong>（IBM SMB：Server Message Block protocol）</strong><br><strong>服务器信息块（SMB）协议是一种IBM协议，用于在计算机间共享文件、打印机、串口等。SMB 协议可以用在因特网的TCP/IP协议之上，也可以用在其它网络协议如IPX和NetBEUI 之上。</strong><br><strong>SMB 一种客户机/服务器、请求/响应协议。通过 SMB 协议，客户端应用程序可以在各种网络环境下读、写服务器上的文件，以及对服务器程序提出服务请求。此外通过 SMB 协议，应用程序可以访问远程服务器端的文件、以及打印机、邮件槽（mailslot）、命名管道（named pipe）等资源。</strong><br><strong>在 TCP/IP 环境下，客户机通过 NetBIOS over TCP/IP（或 NetBEUI/TCP 或 SPX/IPX）连接服务器。一旦连接成功，客户机可发送 SMB 命令到服务器上，从而客户机能够访问共享目录、打开文件、读写文件，以及一切在文件系统上能做的所有事情。</strong><br><strong>从 Windows 95 开始，Microsoft Windows 操作系统（operating system）都包括了客户机和服务器 SMB 协议支持。Microsoft 为 Internet 提供了 SMB 的开源版本，即通用 Internet 文件系统 （CIFS）。与现有 Internet 应用程序如文件传输协议（FTP）相比， CIFS 灵活性更大。对于 UNIX 系统，可使用一种称为 Samba 的共享软件。</strong></p><h2 id="References"><a href="#References" class="headerlink" title="References:"></a>References:</h2><p><a href="https://en.wikipedia.org/wiki/Server_Message_Block">https://en.wikipedia.org/wiki/Server_Message_Block</a></p><p><a href="https://baike.baidu.com/item/smb/4750512?fr=aladdin">https://baike.baidu.com/item/smb/4750512?fr=aladdin</a></p>]]></content>
      
      
      <categories>
          
          <category> Azure </category>
          
          <category> Data Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Azure </tag>
            
            <tag> Data Storage </tag>
            
            <tag> SMB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>What is &#39;Redundant&#39; Data?</title>
      <link href="/posts/38dbfa3f/"/>
      <url>/posts/38dbfa3f/</url>
      
        <content type="html"><![CDATA[<h1 id="What-is-‘Redundant’-Data"><a href="#What-is-‘Redundant’-Data" class="headerlink" title="What is ‘Redundant’ Data?"></a>What is ‘Redundant’ Data?</h1><h2 id="Redundant-Data"><a href="#Redundant-Data" class="headerlink" title="Redundant Data"></a>Redundant Data</h2><p>When it comes to Data Storage, the word ‘redundant’ or ‘ redundancy’ keeps popping up. So what is data redundancy? </p><p>Data redundancy / Redundant data occurs when <strong>the same piece of data exists in multiple places</strong>.</p><p>Human Word Version(Life examples):</p><p>For example: If every shopping record attaches an individual customer data, even they are actually the Same Customer, therefore this will cause Data Redundancy.</p><p>Another simple example is : you store your notes on your computer with Microsoft Word, and the author will always be yourself, but the Word will record you as Author every time in every doc file. So the Author Name in this case would be the redundant data.</p><hr><h2 id="数据冗余"><a href="#数据冗余" class="headerlink" title="数据冗余"></a>数据冗余</h2><p>数据冗余发生在数据库系统中，指的是一个字段在多个表里重复出现。举个例子，如果每条客户购买商品的信息里都连带记录了客户自身的信息，这样的数据冗余可能造成不一致，因为客户自身的信息可能不一样。数据冗余会导致数据异常和损坏，一般来说设计上应该被避免。数据库规范化防止了冗余而且不浪费存储容量。</p><p>适当的使用外键可以使得数据冗余和异常降到最低。但是，如果考虑效率和便利，有时候也会设计冗余数据，而不考虑数据被破坏的风险。</p>]]></content>
      
      
      <categories>
          
          <category> Azure </category>
          
          <category> Data Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redundant </tag>
            
            <tag> Redundancy </tag>
            
            <tag> Data Storage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>What is Container &amp; Docker?</title>
      <link href="/posts/c9b9b3e2/"/>
      <url>/posts/c9b9b3e2/</url>
      
        <content type="html"><![CDATA[<h1 id="What-is-Container-amp-Docker"><a href="#What-is-Container-amp-Docker" class="headerlink" title="What is Container &amp; Docker?"></a>What is Container &amp; Docker?</h1><h2 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h2><h3 id="What-is-Container"><a href="#What-is-Container" class="headerlink" title="What is Container?"></a>What is Container?</h3><p>A container is <strong><u>a standard unit of software</u> that packages up code and all its dependencies</strong> so the application runs quickly and reliably from one computing environment to another.</p><p><strong>Human language Version</strong>😂:</p><p>Imagine the term ‘Container’ is an actual container in life:</p><p><img "" class="lazyload placeholder" data-original="https://cdn.pixabay.com/photo/2016/11/21/13/20/port-1845350_1280.jpg" src="https://cdn.jsdelivr.net/gh/KaiMouraWang/Pics/loading.gif"></p><p>In the old days, if you want to build an app, you have to start from deploying a system such as VM, and different VM(such as Windows &amp; Linux) makes it harder to transfer the app from one system to another.</p><p>Therefore, containers are a solution to the problem of <strong>how to get software to run reliably when <u>moved from one computing environment to another</u>.</strong> </p><p><u><strong>A container consists of an entire runtime environment except they don’t include the operating system: an application, plus all its dependencies, libraries and other binaries, and configuration files needed to run it, bundled into one package.</strong></u> By containerizing the application platform and its dependencies, differences in OS distributions and underlying infrastructure are abstracted away.</p><p><code>In this case:  Different systems are like different quays. And Containers is like actual containers. If you wanna move the containers from Shanghai Quay(Windows) to London Quay(Linux), the containers will not be affected and easy to transfer.</code></p><h4 id="Benefits-of-Docker"><a href="#Benefits-of-Docker" class="headerlink" title="Benefits of  Docker:"></a>Benefits of  Docker:</h4><p>A container may be only tens of megabytes in size, whereas a virtual machine with its own entire operating system may be several gigabytes in size. Because of this, a single server can host far more containers than virtual machines.</p><p>Another major benefit is that virtual machines may take several minutes to boot up their operating systems and begin running the applications they host, while containerized applications can be started almost instantly. That means containers can be instantiated in a “just in time” fashion when they are needed and can disappear when they are no longer required, freeing up resources on their hosts.</p><p>A third benefit is that containerization allows for greater modularity. Rather than run an entire complex application inside a single container, the application can be split in to modules (such as the database, the application front end, and so on). This is the so-called microservices approach.  Applications built in this way are easier to manage because each module is relatively simple, and changes can be made to modules without having to rebuild the entire application. Because containers are so lightweight, individual modules (or microservices) can be instantiated only when they are needed and are available almost immediately.</p><hr><h3 id="什么是容器（Container）"><a href="#什么是容器（Container）" class="headerlink" title="什么是容器（Container）?"></a>什么是容器（Container）?</h3><p>早期，大家都认为硬件抽象层基于hypervisor的虚拟化方式可以最大程度上提供虚拟化管理的灵活性。各种不同操作系统的虚拟机都能通过hypervisor（KVM、XEN等）来衍生、运行、销毁。然而，随着时间推移，用户发现hypervisor这种方式麻烦越来越多。为什么？因为对于hypervisor环境来说，<strong>每个虚拟机都需要运行一个完整的操作系统以及其中安装好的大量应用程序</strong>。但实际生产开发环境里，我们更关注的是自己部署的应用程序，如果每次部署发布我都得搞一个完整操作系统和附带的依赖环境，那么这让任务和性能变得很重和很低下。</p><p>基于上述情况，人们就在想，有没有其他什么方式能让人更加的关注应用程序本身，底层多余的操作系统和环境我可以共享和复用？<strong>换句话来说，那就是<u>我部署一个服务运行好后，我再想移植到另外一个地方，我可以不用再安装一套操作系统和依赖环境</u>。</strong>这就像集装箱运载一样，我把货物一辆兰博基尼跑车（好比开发好的应用APP），打包放到一容器集装箱里，它通过货轮可以轻而易举的从上海码头（CentOS7.2环境）运送到纽约码头（Ubuntu14.04环境）。而且运输期间，我的兰博基尼（APP）没有受到任何的损坏（文件没有丢失），在另外一个码头卸货后，依然可以完美风骚的赛跑（启动正常）。</p><p>Linux Container容器技术的诞生（2008年）就解决了IT世界里“集装箱运输”的问题。Linux Container（简称LXC）它是一种内核轻量级的操作系统层虚拟化技术。Linux Container主要由Namespace和Cgroup两大机制来保证实现。那么Namespace和Cgroup是什么呢？刚才我们上面提到了集装箱，集装箱的作用当然是可以对货物进行打包隔离了，不让A公司的货跟B公司的货混在一起，不然卸货就分不清楚了。那么Namespace也是一样的作用，做隔离。光有隔离还没用，我们还需要对货物进行资源的管理。同样的，航运码头也有这样的管理机制：货物用什么样规格大小的集装箱，货物用多少个集装箱，货物哪些优先运走，遇到极端天气怎么暂停运输服务怎么改航道等等… 通用的，与此对应的Cgroup就负责资源管理控制作用，比如进程组使用CPU/MEM的限制，进程组的优先级控制，进程组的挂起和恢复等等。</p><p>Linux Container容器技术的诞生（2008年）就解决了IT世界里“集装箱运输”的问题。Linux Container（简称LXC）它是一种内核轻量级的操作系统层虚拟化技术。Linux Container主要由Namespace和Cgroup两大机制来保证实现。那么Namespace和Cgroup是什么呢？刚才我们上面提到了集装箱，集装箱的作用当然是可以对货物进行打包隔离了，不让A公司的货跟B公司的货混在一起，不然卸货就分不清楚了。那么Namespace也是一样的作用，做隔离。光有隔离还没用，我们还需要对货物进行资源的管理。同样的，航运码头也有这样的管理机制：货物用什么样规格大小的集装箱，货物用多少个集装箱，货物哪些优先运走，遇到极端天气怎么暂停运输服务怎么改航道等等… 通用的，与此对应的Cgroup就负责资源管理控制作用，比如进程组使用CPU/MEM的限制，进程组的优先级控制，进程组的挂起和恢复等等。</p><hr><h4 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h4><p>容器的特点其实我们拿跟它跟硬件抽象层虚拟化hypervisor技术对比就清楚了，我们之前也提到过，传统的虚拟化（虚拟机）技术，创建环境和部署应用都很麻烦，而且应用的移植性也很繁琐，比如你要把vmware里的虚拟机迁移到KVM里就很繁琐（需要做镜像格式的转换）。那么有了容器技术就简单了，总结下容器技术主要有三个特点：</p><pre><code>1. 极其轻量：只打包了必要的Bin/Lib；2. 秒级部署：根据镜像的不同，容器的部署大概在毫秒与秒之间（比虚拟机强很多）；3. 易于移植：一次构建，随处部署；4. 弹性伸缩：Kubernetes、Swam、Mesos这类开源、方便、好使的容器管理平台有着非常强大的弹性管理能力。</code></pre><h2 id="What-is-Docker"><a href="#What-is-Docker" class="headerlink" title="What is Docker?"></a>What is Docker?</h2><h3 id="What-is-Docker-1"><a href="#What-is-Docker-1" class="headerlink" title="What is Docker?"></a>What is Docker?</h3><p>Docker is <u><strong>not</strong> equal</u> to Container. It’s just <u>one of the platforms</u> that can deliver containers.</p><p><strong>Docker is a set of platform as a service products that use OS-level virtualization to deliver software in packages called containers.</strong> </p><hr><h3 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker?"></a>什么是Docker?</h3><p>当前，docker几乎是容器的代名词，很多人以为docker就是容器。其实，这是错误的认识，除了docker  还有coreos。所以，容器世界里并不是只有docker一家。既然不是一家就很容易出现分歧。任何技术出现都需要一个标准来规范它，不然各搞各的很容易导致技术实现的碎片化，出现大量的冲突和冗余。因此，在2015年，由Google，Docker、CoreOS、IBM、微软、红帽等厂商联合发起的OCI（Open Container  Initiative）组织成立了，并于2016年4月推出了第一个开放容器标准。标准主要包括runtime运行时标准和image镜像标准。标准的推出，有助于替成长中市场带来稳定性，让企业能放心采用容器技术，用户在打包、部署应用程序后，可以自由选择不同的容器Runtime；同时，镜像打包、建立、认证、部署、命名也都能按照统一的规范来做。</p><p>两种标准主要包含以下内容：</p><p><code>1.容器运行时标准 （runtime spec）</code></p><p>a). creating：使用 create 命令创建容器，这个过程称为创建中 b). created：容器创建出来，但是还没有运行，表示镜像和配置没有错误，容器能够运行在当前平台 c). running：容器的运行状态，里面的进程处于 up 状态，正在执行用户设定的任务 d). stopped：容器运行完成，或者运行出错，或者 stop 命令之后，容器处于暂停状态。这个状态，容器还有很多信息保存在平台中，并没有完全被删除</p><p><code>2.容器镜像标准（image spec）</code></p><p>a). 文件系统：以 layer 保存的文件系统，每个 layer 保存了和上层之间变化的部分，layer 应该保存哪些文件，怎么表示增加、修改和删除的文件等; b). config 文件：保存了文件系统的层级信息（每个层级的 hash 值，以及历史信息），以及容器运行时需要的一些信息（比如环境变量、工作目录、命令参数、mount 列表），指定了镜像在某个特定平台和系统的配置。比较接近我们使用 docker inspect <image_id> 看到的内容; c). manifest 文件：镜像的 config 文件索引，有哪些 layer，额外的 annotation 信息，manifest 文件中保存了很多和当前平台有关的信息; d). index 文件：可选的文件，指向不同平台的 manifest 文件，这个文件能保证一个镜像可以跨平台使用，每个平台拥有不同的 manifest 文件，使用 index 作为索引。</p><h2 id="Related-Quiz"><a href="#Related-Quiz" class="headerlink" title="Related Quiz:"></a>Related Quiz:</h2><p>Q: Which service simplifies the process of configuring, deploying, and  managing a simple containerized application on the Azure cloud?</p><ol><li><p>Azure Container Instances</p></li><li><p>Azure Functions</p></li><li><p>Azure App Service</p></li><li><p>Azure Pipelines</p></li></ol><p>A: Azure Container Instances</p><p>Containers are somewhat like virtual machines except they don’t include the operating system. This makes it easy to deploy them because they’re very lightweight compared to virtual machines. In fact, containers run on virtual machines.</p><p>Microsoft provides a variety of ways to run containers. The simplest way is to use Azure Container Instances. This service lets you run a container using a single command.</p><hr><p>Q: What Azure Cloud compute service is useful when planning a ‘lift-and-shift” migration of an application from an on-premises environment to the Azure Cloud?</p><ol><li><p>Azure Virtual Machines</p></li><li><p>Azure Functions</p></li><li><p>Azure Container Instances</p></li><li><p>Azure DevOps</p></li></ol><p>A: Azure Container Instances</p><p>If you currently have an application running on a Windows or Linux server, then the most straightforward way to migrate it to Azure is to do what’s called a “lift and shift” migration. That is, you simply lift the application from your on-premises server and shift it to a virtual server in the cloud. Azure VMs are known as Infrastructure-as-a-Service because they’re traditional IT infrastructure components that are offered as a service.</p><h2 id="References-amp-Credit："><a href="#References-amp-Credit：" class="headerlink" title="References &amp; Credit："></a>References &amp; Credit：</h2><p><a href="https://www.cnblogs.com/qcloud1001/p/9273549.html">https://www.cnblogs.com/qcloud1001/p/9273549.html</a></p><p><a href="https://www.cio.com/article/2924995/what-are-containers-and-why-do-you-need-them.html">https://www.cio.com/article/2924995/what-are-containers-and-why-do-you-need-them.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Azure </category>
          
          <category> Data Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> container </tag>
            
            <tag> docker </tag>
            
            <tag> Azure </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
